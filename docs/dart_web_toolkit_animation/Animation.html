        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>Animation abstract class / dart_web_toolkit_animation Library / API Reference / Dart Web Toolkit</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        <script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-40672112-1']);
  _gaq.push(['_setDomainName', 'dartwebtoolkit.com']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
</head>
        <body data-library="dart_web_toolkit_animation" data-type="Animation">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">API Reference 0.3.16</a>
         &rsaquo; <a href="../dart_web_toolkit_animation.html">dart_web_toolkit_animation</a> &rsaquo; <a href="../dart_web_toolkit_animation/Animation.html">Animation</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>Animation</strong>
          abstract class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<p>An {@link Animation} is a continuous event that updates progressively over
time at a non-fixed frame rate.</p>
<pre class="source">
abstract class Animation {

 AnimationCallback callback;


 /**
  * The duration of the {@link Animation} in milliseconds.
  */
 int duration = -1;

 /**
  * The element being animated.
  */
 dart_html.Element element;

 /**
  * Is the animation running, even if it hasn't started yet.
  */
 bool running = false;

 /**
  * Has the {@link Animation} actually started.
  */
 bool isStarted = false;

 /**
  * The ID of the pending animation request.
  */
 AnimationHandle requestHandle;

 /**
  * The unique ID of the current run. Used to handle cases where an animation
  * is restarted within an execution block.
  */
 int runId = -1;

 AnimationScheduler scheduler;

 /**
  * The start time of the {@link Animation}.
  */
 int startTime = -1;

 /**
  * Did the animation start before {@link #cancel()} was called.
  */
 bool wasStarted = false;

 /**
  * Construct a new {@link AnimationScheduler} using the specified scheduler to
  * sheduler request frames.
  *
  * @param scheduler an {@link AnimationScheduler} instance
  */
 Animation([AnimationScheduler scheduler = null]) {
   if (scheduler == null) {
     this.scheduler = new AnimationScheduler.Instance();
   } else {
     this.scheduler = scheduler;
   }
   this.callback = new AnimationCallback2(this);
 }

 /**
  * Immediately cancel this animation. If the animation is running or is
  * scheduled to run, {@link #onCancel()} will be called.
  */
 void cancel() {
   // Ignore if the animation is not currently running.
   if (!running) {
     return;
   }

   // Reset the state.
   wasStarted = isStarted; // Used by onCancel.
   element = null;
   running = false;
   isStarted = false;

   // Cancel the animation request.
   if (requestHandle != null) {
     requestHandle.cancel();
     requestHandle = null;
   }

   onCancel();
 }

//  /**
//   * Immediately run this animation. If the animation is already running, it
//   * will be canceled first.
//   * &lt;p&gt;
//   * This is equivalent to &lt;code&gt;run(duration, null)&lt;/code&gt;.
//   *
//   * @param duration the duration of the animation in milliseconds
//   * @see #run(int, Element)
//   */
//  void run(int duration) {
//    run(duration, null);
//  }
//
//  /**
//   * Immediately run this animation. If the animation is already running, it
//   * will be canceled first.
//   * &lt;p&gt;
//   * If the element is not &lt;code&gt;null&lt;/code&gt;, the {@link #onUpdate(double)}
//   * method might be called only if the element may be visible (generally left
//   * at the appreciation of the browser). Otherwise, it will be called
//   * unconditionally.
//   *
//   * @param duration the duration of the animation in milliseconds
//   * @param element the element that visually bounds the entire animation
//   */
//  void run(int duration, Element element) {
//    run(duration, Duration.currentTimeMillis(), element);
//  }
//
//  /**
//   * Run this animation at the given startTime. If the startTime has already
//   * passed, the animation will run synchronously as if it started at the
//   * specified start time. If the animation is already running, it will be
//   * canceled first.
//   * &lt;p&gt;
//   * This is equivalent to &lt;code&gt;run(duration, startTime, null)&lt;/code&gt;.
//   *
//   * @param duration the duration of the animation in milliseconds
//   * @param startTime the synchronized start time in milliseconds
//   * @see #run(int, double, Element)
//   */
//  void run(int duration, double startTime) {
//    run(duration, startTime, null);
//  }

 /**
  * Run this animation at the given startTime. If the startTime has already
  * passed, the animation will run synchronously as if it started at the
  * specified start time. If the animation is already running, it will be
  * canceled first.
  * &lt;p&gt;
  * If the element is not &lt;code&gt;null&lt;/code&gt;, the {@link #onUpdate(double)}
  * method might be called only if the element may be visible (generally left
  * at the appreciation of the browser). Otherwise, it will be called
  * unconditionally.
  *
  * @param duration the duration of the animation in milliseconds
  * @param startTime the synchronized start time in milliseconds
  * @param element the element that visually bounds the entire animation
  */
 void run(int duration, {int startTime:null, dart_html.Element element:null}) {
   // Cancel the animation if it is running
   cancel();

   if (startTime == null) {
     startTime = (new DateTime.now()).millisecondsSinceEpoch;
   }

   // Save the duration and startTime
   running = true;
   isStarted = false;
   this.duration = duration;
   this.startTime = startTime;
   this.element = element;
   ++runId;

   // Execute the first callback.
   callback.execute((new DateTime.now()).millisecondsSinceEpoch);
 }

 /**
  * Interpolate the linear progress into a more natural easing function.
  *
  * Depending on the {@link Animation}, the return value of this method can be
  * less than 0.0 or greater than 1.0.
  *
  * @param progress the linear progress, between 0.0 and 1.0
  * @return the interpolated progress
  */
 double interpolate(double progress) {
   return (1 + dart_math.cos(dart_math.PI + progress * dart_math.PI)) / 2;
 }

 /**
  * Called immediately after the animation is canceled. The default
  * implementation of this method calls {@link #onComplete()} only if the
  * animation has actually started running.
  */
 void onCancel() {
   if (wasStarted) {
     onComplete();
   }
 }

 /**
  * Called immediately after the animation completes.
  */
 void onComplete() {
   onUpdate(interpolate(1.0));
 }

 /**
  * Called immediately before the animation starts.
  */
 void onStart() {
   onUpdate(interpolate(0.0));
 }

 /**
  * Called when the animation should be updated.
  *
  * The value of progress is between 0.0 and 1.0 (inclusive) (unless you
  * override the {@link #interpolate(double)} method to provide a wider range
  * of values). You can override {@link #onStart()} and {@link #onComplete()}
  * to perform setup and tear down procedures.
  *
  * @param progress a double, normally between 0.0 and 1.0 (inclusive)
  */
 void onUpdate(double progress);

 /**
  * Check if the specified run ID is still being run.
  *
  * @param curRunId the current run ID to check
  * @return true if running, false if canceled or restarted
  */
 bool isRunning(int curRunId) {
   return running &amp;&amp; (runId == curRunId);
 }

 /**
  * Update the {@link Animation}.
  *
  * @param curTime the current time
  * @return true if the animation should run again, false if it is complete
  */
 bool update(int curTime) {
   /*
    * Save the run id. If the runId is incremented during this execution block,
    * we know that this run has been canceled.
    */
   int curRunId = runId;

   bool finished = curTime &gt;= startTime + duration;
   if (isStarted &amp;&amp; !finished) {
     // Animation is in progress.
     double progress = (curTime - startTime) / duration;
     onUpdate(interpolate(progress));
     return isRunning(curRunId); // Check if this run was canceled.
   }
   if (!isStarted &amp;&amp; curTime &gt;= startTime) {
     /*
      * Start the animation. We do not call onUpdate() because onStart() calls
      * onUpdate() by default.
      */
     isStarted = true;
     onStart();
     if (!isRunning(curRunId)) {
       // This run was canceled.
       return false;
     }
     // Intentional fall through to possibly end the animation.
   }
   if (finished) {
     // Animation is complete.
     running = false;
     isStarted = false;
     onComplete();
     return false;
   }
   return true;
 }

}
</pre>
</div>
<h3>Subclasses</h3>
<p>
<span class="type-box"><span class="icon-class"></span><a href="../dart_web_toolkit_layout/LayoutAnimation.html">LayoutAnimation</a></span>, <span class="type-box"><span class="icon-class"></span><a href="../dart_web_toolkit_ui/ResizeAnimation.html">ResizeAnimation</a></span>, <span class="type-box"><span class="icon-class"></span><a href="../dart_web_toolkit_ui/TreeItemAnimation.html">TreeItemAnimation</a></span></p>
<div>
<h3>Constructors</h3>
<div class="method"><h4 id="Animation">
<button class="show-code">Code</button>
new <strong>Animation</strong>([<a href="../dart_web_toolkit_animation/AnimationScheduler.html">AnimationScheduler</a> scheduler = null]) <a class="anchor-link" href="#Animation"
              title="Permalink to Animation.Animation">#</a></h4>
<div class="doc">
<p>Construct a new {@link AnimationScheduler} using the specified scheduler to
sheduler request frames.</p>
<p>@param scheduler an {@link AnimationScheduler} instance</p>
<pre class="source">
Animation([AnimationScheduler scheduler = null]) {
 if (scheduler == null) {
   this.scheduler = new AnimationScheduler.Instance();
 } else {
   this.scheduler = scheduler;
 }
 this.callback = new AnimationCallback2(this);
}
</pre>
</div>
</div>
</div>
<div>
<h3>Properties</h3>
<div class="field"><h4 id="callback">
<button class="show-code">Code</button>
<a href="../dart_web_toolkit_animation/AnimationCallback.html">AnimationCallback</a>         <strong>callback</strong> <a class="anchor-link"
            href="#callback"
            title="Permalink to Animation.callback">#</a>
        </h4>
        <div class="doc">
<pre class="source">
AnimationCallback callback
</pre>
</div>
</div>
<div class="field"><h4 id="duration">
<button class="show-code">Code</button>
int         <strong>duration</strong> <a class="anchor-link"
            href="#duration"
            title="Permalink to Animation.duration">#</a>
        </h4>
        <div class="doc">
<p>The duration of the {@link Animation} in milliseconds.</p>
<pre class="source">
int duration = -1
</pre>
</div>
</div>
<div class="field"><h4 id="element">
<button class="show-code">Code</button>
Element         <strong>element</strong> <a class="anchor-link"
            href="#element"
            title="Permalink to Animation.element">#</a>
        </h4>
        <div class="doc">
<p>The element being animated.</p>
<pre class="source">
dart_html.Element element
</pre>
</div>
</div>
<div class="field"><h4 id="isStarted">
<button class="show-code">Code</button>
bool         <strong>isStarted</strong> <a class="anchor-link"
            href="#isStarted"
            title="Permalink to Animation.isStarted">#</a>
        </h4>
        <div class="doc">
<p>Has the {@link Animation} actually started.</p>
<pre class="source">
bool isStarted = false
</pre>
</div>
</div>
<div class="field"><h4 id="requestHandle">
<button class="show-code">Code</button>
<a href="../dart_web_toolkit_animation/AnimationHandle.html">AnimationHandle</a>         <strong>requestHandle</strong> <a class="anchor-link"
            href="#requestHandle"
            title="Permalink to Animation.requestHandle">#</a>
        </h4>
        <div class="doc">
<p>The ID of the pending animation request.</p>
<pre class="source">
AnimationHandle requestHandle
</pre>
</div>
</div>
<div class="field"><h4 id="runId">
<button class="show-code">Code</button>
int         <strong>runId</strong> <a class="anchor-link"
            href="#runId"
            title="Permalink to Animation.runId">#</a>
        </h4>
        <div class="doc">
<p>The unique ID of the current run. Used to handle cases where an animation
is restarted within an execution block.</p>
<pre class="source">
int runId = -1
</pre>
</div>
</div>
<div class="field"><h4 id="running">
<button class="show-code">Code</button>
bool         <strong>running</strong> <a class="anchor-link"
            href="#running"
            title="Permalink to Animation.running">#</a>
        </h4>
        <div class="doc">
<p>Is the animation running, even if it hasn't started yet.</p>
<pre class="source">
bool running = false
</pre>
</div>
</div>
<div class="field"><h4 id="scheduler">
<button class="show-code">Code</button>
<a href="../dart_web_toolkit_animation/AnimationScheduler.html">AnimationScheduler</a>         <strong>scheduler</strong> <a class="anchor-link"
            href="#scheduler"
            title="Permalink to Animation.scheduler">#</a>
        </h4>
        <div class="doc">
<pre class="source">
AnimationScheduler scheduler
</pre>
</div>
</div>
<div class="field"><h4 id="startTime">
<button class="show-code">Code</button>
int         <strong>startTime</strong> <a class="anchor-link"
            href="#startTime"
            title="Permalink to Animation.startTime">#</a>
        </h4>
        <div class="doc">
<p>The start time of the {@link Animation}.</p>
<pre class="source">
int startTime = -1
</pre>
</div>
</div>
<div class="field"><h4 id="wasStarted">
<button class="show-code">Code</button>
bool         <strong>wasStarted</strong> <a class="anchor-link"
            href="#wasStarted"
            title="Permalink to Animation.wasStarted">#</a>
        </h4>
        <div class="doc">
<p>Did the animation start before {@link #cancel()} was called.</p>
<pre class="source">
bool wasStarted = false
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method"><h4 id="cancel">
<button class="show-code">Code</button>
void <strong>cancel</strong>() <a class="anchor-link" href="#cancel"
              title="Permalink to Animation.cancel">#</a></h4>
<div class="doc">
<p>Immediately cancel this animation. If the animation is running or is
scheduled to run, {@link #onCancel()} will be called.</p>
<pre class="source">
void cancel() {
 // Ignore if the animation is not currently running.
 if (!running) {
   return;
 }

 // Reset the state.
 wasStarted = isStarted; // Used by onCancel.
 element = null;
 running = false;
 isStarted = false;

 // Cancel the animation request.
 if (requestHandle != null) {
   requestHandle.cancel();
   requestHandle = null;
 }

 onCancel();
}
</pre>
</div>
</div>
<div class="method"><h4 id="interpolate">
<button class="show-code">Code</button>
double <strong>interpolate</strong>(double progress) <a class="anchor-link" href="#interpolate"
              title="Permalink to Animation.interpolate">#</a></h4>
<div class="doc">
<p>Interpolate the linear progress into a more natural easing function.</p>
<p>Depending on the {@link Animation}, the return value of this method can be
less than 0.0 or greater than 1.0.</p>
<p>@param progress the linear progress, between 0.0 and 1.0
@return the interpolated progress</p>
<pre class="source">
double interpolate(double progress) {
 return (1 + dart_math.cos(dart_math.PI + progress * dart_math.PI)) / 2;
}
</pre>
</div>
</div>
<div class="method"><h4 id="isRunning">
<button class="show-code">Code</button>
bool <strong>isRunning</strong>(int curRunId) <a class="anchor-link" href="#isRunning"
              title="Permalink to Animation.isRunning">#</a></h4>
<div class="doc">
<p>Check if the specified run ID is still being run.</p>
<p>@param curRunId the current run ID to check
@return true if running, false if canceled or restarted</p>
<pre class="source">
bool isRunning(int curRunId) {
 return running &amp;&amp; (runId == curRunId);
}
</pre>
</div>
</div>
<div class="method"><h4 id="onCancel">
<button class="show-code">Code</button>
void <strong>onCancel</strong>() <a class="anchor-link" href="#onCancel"
              title="Permalink to Animation.onCancel">#</a></h4>
<div class="doc">
<p>Called immediately after the animation is canceled. The default
implementation of this method calls {@link #onComplete()} only if the
animation has actually started running.</p>
<pre class="source">
void onCancel() {
 if (wasStarted) {
   onComplete();
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="onComplete">
<button class="show-code">Code</button>
void <strong>onComplete</strong>() <a class="anchor-link" href="#onComplete"
              title="Permalink to Animation.onComplete">#</a></h4>
<div class="doc">
<p>Called immediately after the animation completes.</p>
<pre class="source">
void onComplete() {
 onUpdate(interpolate(1.0));
}
</pre>
</div>
</div>
<div class="method"><h4 id="onStart">
<button class="show-code">Code</button>
void <strong>onStart</strong>() <a class="anchor-link" href="#onStart"
              title="Permalink to Animation.onStart">#</a></h4>
<div class="doc">
<p>Called immediately before the animation starts.</p>
<pre class="source">
void onStart() {
 onUpdate(interpolate(0.0));
}
</pre>
</div>
</div>
<div class="method"><h4 id="onUpdate">
abstract void <strong>onUpdate</strong>(double progress) <a class="anchor-link" href="#onUpdate"
              title="Permalink to Animation.onUpdate">#</a></h4>
<div class="doc">
<p>Called when the animation should be updated.</p>
<p>The value of progress is between 0.0 and 1.0 (inclusive) (unless you
override the {@link #interpolate(double)} method to provide a wider range
of values). You can override {@link #onStart()} and {@link #onComplete()}
to perform setup and tear down procedures.</p>
<p>@param progress a double, normally between 0.0 and 1.0 (inclusive)</p>
</div>
</div>
<div class="method"><h4 id="run">
<button class="show-code">Code</button>
void <strong>run</strong>(int duration, {int startTime: null, Element element: null}) <a class="anchor-link" href="#run"
              title="Permalink to Animation.run">#</a></h4>
<div class="doc">
<p>Run this animation at the given startTime. If the startTime has already
passed, the animation will run synchronously as if it started at the
specified start time. If the animation is already running, it will be
canceled first.
&lt;p>
If the element is not &lt;code>null&lt;/code>, the {@link #onUpdate(double)}
method might be called only if the element may be visible (generally left
at the appreciation of the browser). Otherwise, it will be called
unconditionally.</p>
<p>@param duration the duration of the animation in milliseconds
@param startTime the synchronized start time in milliseconds
@param element the element that visually bounds the entire animation</p>
<pre class="source">
void run(int duration, {int startTime:null, dart_html.Element element:null}) {
 // Cancel the animation if it is running
 cancel();

 if (startTime == null) {
   startTime = (new DateTime.now()).millisecondsSinceEpoch;
 }

 // Save the duration and startTime
 running = true;
 isStarted = false;
 this.duration = duration;
 this.startTime = startTime;
 this.element = element;
 ++runId;

 // Execute the first callback.
 callback.execute((new DateTime.now()).millisecondsSinceEpoch);
}
</pre>
</div>
</div>
<div class="method"><h4 id="update">
<button class="show-code">Code</button>
bool <strong>update</strong>(int curTime) <a class="anchor-link" href="#update"
              title="Permalink to Animation.update">#</a></h4>
<div class="doc">
<p>Update the {@link Animation}.</p>
<p>@param curTime the current time
@return true if the animation should run again, false if it is complete</p>
<pre class="source">
bool update(int curTime) {
 /*
  * Save the run id. If the runId is incremented during this execution block,
  * we know that this run has been canceled.
  */
 int curRunId = runId;

 bool finished = curTime &gt;= startTime + duration;
 if (isStarted &amp;&amp; !finished) {
   // Animation is in progress.
   double progress = (curTime - startTime) / duration;
   onUpdate(interpolate(progress));
   return isRunning(curRunId); // Check if this run was canceled.
 }
 if (!isStarted &amp;&amp; curTime &gt;= startTime) {
   /*
    * Start the animation. We do not call onUpdate() because onStart() calls
    * onUpdate() by default.
    */
   isStarted = true;
   onStart();
   if (!isRunning(curRunId)) {
     // This run was canceled.
     return false;
   }
   // Intentional fall through to possibly end the animation.
 }
 if (finished) {
   // Animation is complete.
   running = false;
   isStarted = false;
   onComplete();
   return false;
 }
 return true;
}
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          <div>This page was generated at 2013-06-20 08:55:58.924</div>
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        
