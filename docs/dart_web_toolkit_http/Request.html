        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>Request class / dart_web_toolkit_http Library / API Reference / Dart Web Toolkit</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        <script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-40672112-1']);
  _gaq.push(['_setDomainName', 'dartwebtoolkit.com']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
</head>
        <body data-library="dart_web_toolkit_http" data-type="Request">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">API Reference 0.3.8+1</a>
         &rsaquo; <a href="../dart_web_toolkit_http.html">dart_web_toolkit_http</a> &rsaquo; <a href="../dart_web_toolkit_http/Request.html">Request</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>Request</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<p>An HTTP request that is waiting for a response. Requests can be queried for
their pending status or they can be canceled.</p><h3>Required Module</h3> Modules that use this class should inherit
<code>com.google.gwt.http.HTTP</code>.
<p>{@gwt.include
com/google/gwt/examples/http/InheritsExample.gwt.xml}</p>
<pre class="source">
class Request {

 /**
  * Creates a {@link Response} instance for the given JavaScript XmlHttpRequest
  * object.
  *
  * @param xmlHttpRequest xmlHttpRequest object for which we need a response
  * @return a {@link Response} object instance
  */
 static Response createResponse(dart_html.HttpRequest xmlHttpRequest) {
   assert (isResponseReady(xmlHttpRequest));
   Response response = new _Response(xmlHttpRequest);
   return response;
 }

 /**
  * Returns an array of headers built by parsing the string of headers returned
  * by the JavaScript &lt;code&gt;XmlHttpRequest&lt;/code&gt; object.
  *
  * @param xmlHttpRequest
  * @return array of Header items
  */
 static List&lt;Header&gt; getHeaders(dart_html.HttpRequest xmlHttp) {
   String allHeaders = xmlHttp.getAllResponseHeaders();
   List&lt;String&gt; unparsedHeaders = allHeaders.split("\n");
   List&lt;Header&gt; parsedHeaders = new List&lt;Header&gt;(unparsedHeaders.length);

   for (int i = 0, n = unparsedHeaders.length; i &lt; n; ++i) {
     String unparsedHeader = unparsedHeaders[i];

     if (unparsedHeader.length == 0) {
       continue;
     }

     int endOfNameIdx = unparsedHeader.indexOf(':');
     if (endOfNameIdx &lt; 0) {
       continue;
     }

     String name = unparsedHeader.substring(0, endOfNameIdx).trim();
     String value = unparsedHeader.substring(endOfNameIdx + 1).trim();
     Header header = new _RequestHeader(name, value);

     parsedHeaders[i] = header;
   }

   return parsedHeaders;
 }

 static bool isResponseReady(dart_html.HttpRequest xhr) {
   return xhr.readyState == dart_html.HttpRequest.DONE;
 }


 /**
  * The number of milliseconds to wait for this HTTP request to complete.
  */
 int _timeoutMillis = 0;

 /*
  * Timer used to force HTTPRequest timeouts. If the user has not requested a
  * timeout then this field is null.
  */
 dart_async.Timer _timer;

 /*
  * JavaScript XmlHttpRequest object that this Java class wraps. This field is
  * not final because we transfer ownership of it to the HTTPResponse object
  * and set this field to null.
  */
 dart_html.HttpRequest _xmlHttpRequest;

 /**
  * Only used for building a
  * {@link com.google.gwt.user.client.rpc.impl.FailedRequest}.
  */
 Request.internal();

 /**
  * Constructs an instance of the Request object.
  *
  * @param xmlHttpRequest JavaScript XmlHttpRequest object instance
  * @param timeoutMillis number of milliseconds to wait for a response
  * @param callback callback interface to use for notification
  *
  * @throws IllegalArgumentException if timeoutMillis &amp;lt; 0
  * @throws NullPointerException if xmlHttpRequest, or callback are null
  */
 Request(dart_html.HttpRequest xmlHttpRequest, int timeoutMillis, RequestCallback callback) {
   if (xmlHttpRequest == null) {
     throw new Exception();
   }

   if (callback == null) {
     throw new Exception();
   }

   if (timeoutMillis &lt; 0) {
     throw new Exception();
   }

   this._timeoutMillis = timeoutMillis;

   this._xmlHttpRequest = xmlHttpRequest;

   if (timeoutMillis &gt; 0) {
     // create and start a Timer
     _timer = new dart_async.Timer(new Duration(milliseconds:timeoutMillis), (){
       _fireOnTimeout(callback);
     });
   } else {
     // no Timer required
     _timer = null;
   }
 }

 /**
  * Cancels a pending request. If the request has already been canceled or if
  * it has timed out no action is taken.
  */
 void cancel() {
   /*
    * There is a strange race condition that occurs on Mozilla when you cancel
    * a request while the response is coming in. It appears that in some cases
    * the onreadystatechange handler is still called after the handler function
    * has been deleted and during the call to XmlHttpRequest.abort(). So we
    * null the xmlHttpRequest here and that will prevent the
    * fireOnResponseReceived method from calling the callback function.
    *
    * Setting the onreadystatechange handler to null gives us the correct
    * behavior in Mozilla but crashes IE. That is why we have chosen to fixed
    * this in Java by nulling out our reference to the XmlHttpRequest object.
    */
   if (_xmlHttpRequest != null) {
     dart_html.HttpRequest xmlHttp = _xmlHttpRequest;
     _xmlHttpRequest = null;

     //xmlHttp.onReadyStateChange. readyStateChangeEvent.addListener(listener); // clearOnReadyStateChange();
     xmlHttp.onReadyStateChange.listen(null, onError:null, onDone:null, unsubscribeOnError:true);
     xmlHttp.abort();

     _cancelTimer();
   }
 }

 /**
  * Returns true if this request is waiting for a response.
  *
  * @return true if this request is waiting for a response
  */
 bool isPending() {
   if (_xmlHttpRequest == null) {
     return false;
   }

   int readyState = _xmlHttpRequest.readyState;

   /*
    * Because we are doing asynchronous requests it is possible that we can
    * call XmlHttpRequest.send and still have the XmlHttpRequest.getReadyState
    * method return the state as XmlHttpRequest.OPEN. That is why we include
    * open although it is nottechnically true since open implies that the
    * request has not been sent.
    */
   switch (readyState) {
     case dart_html.HttpRequest.OPENED:
     case dart_html.HttpRequest.HEADERS_RECEIVED:
     case dart_html.HttpRequest.LOADING:
       return true;
   }

   return false;
 }

 /*
  * Method called when the JavaScript XmlHttpRequest object's readyState
  * reaches 4 (LOADED).
  */
 void fireOnResponseReceived(RequestCallback callback) {
   if (_xmlHttpRequest == null) {
     // the request has timed out at this point
     return;
   }

   _cancelTimer();

   /*
    * We cannot use cancel here because it would clear the contents of the
    * JavaScript XmlHttpRequest object so we manually null out our reference to
    * the JavaScriptObject
    */
   dart_html.HttpRequest xhr = _xmlHttpRequest;
   _xmlHttpRequest = null;

   String errorMsg = _getBrowserSpecificFailure(xhr);
   if (errorMsg != null) {
     Exception exception = new Exception(errorMsg);
     callback.onError(this, exception);
   } else {
     Response response = createResponse(xhr);
     callback.onResponseReceived(this, response);
   }
 }

 /*
  * Stops the current HTTPRequest timer if there is one.
  */
 void _cancelTimer() {
   if (_timer != null) {
     _timer.cancel();
   }
 }

 /*
  * Method called when this request times out.
  *
  * NOTE: this method is called from JSNI
  */
 void _fireOnTimeout(RequestCallback callback) {
   if (_xmlHttpRequest == null) {
     // the request has been received at this point
     return;
   }

   cancel();

   callback.onError(this, new Exception()); //this, _timeoutMillis));
 }

 /**
  * Tests if the JavaScript &lt;code&gt;XmlHttpRequest.status&lt;/code&gt; property is
  * readable. This can return failure in two different known scenarios:
  *
  * &lt;ol&gt;
  * &lt;li&gt;On Mozilla, after a network error, attempting to read the status code
  * results in an exception being thrown. See &lt;a
  * href="https://bugzilla.mozilla.org/show_bug.cgi?id=238559"
  * &gt;https://bugzilla.mozilla.org/show_bug.cgi?id=238559&lt;/a&gt;.&lt;/li&gt;
  * &lt;li&gt;On Safari, if the HTTP response does not include any response text. See
  * &lt;a
  * href="http://bugs.webkit.org/show_bug.cgi?id=3810"&gt;http://bugs.webkit.org
  * /show_bug.cgi?id=3810&lt;/a&gt;.&lt;/li&gt;
  * &lt;/ol&gt;
  *
  * @param xhr the JavaScript &lt;code&gt;XmlHttpRequest&lt;/code&gt; object to test
  * @return a String message containing an error message if the
  *         &lt;code&gt;XmlHttpRequest.status&lt;/code&gt; code is unreadable or null if
  *         the status code could be successfully read.
  */
 String _getBrowserSpecificFailure(dart_html.HttpRequest xhr) {
   try {
     if (xhr.status == null) {
       return "XmlHttpRequest.status == undefined, please see Safari bug http://bugs.webkit.org/show_bug.cgi?id=3810 for more details";
     }
     return null;
   } on Exception catch (e) {
     return "Unable to read XmlHttpRequest.status; likely causes are a networking error or bad cross-domain request. Please see https://bugzilla.mozilla.org/show_bug.cgi?id=238559 for more details";
   }
 }
}
</pre>
</div>
<div>
<h3>Static Methods</h3>
<div class="method"><h4 id="createResponse">
<button class="show-code">Code</button>
<a href="../dart_web_toolkit_http/Response.html">Response</a> <strong>createResponse</strong>(HttpRequest xmlHttpRequest) <a class="anchor-link" href="#createResponse"
              title="Permalink to Request.createResponse">#</a></h4>
<div class="doc">
<p>Creates a {@link Response} instance for the given JavaScript XmlHttpRequest
object.</p>
<p>@param xmlHttpRequest xmlHttpRequest object for which we need a response
@return a {@link Response} object instance</p>
<pre class="source">
static Response createResponse(dart_html.HttpRequest xmlHttpRequest) {
 assert (isResponseReady(xmlHttpRequest));
 Response response = new _Response(xmlHttpRequest);
 return response;
}
</pre>
</div>
</div>
<div class="method"><h4 id="getHeaders">
<button class="show-code">Code</button>
List&lt;<a href="../dart_web_toolkit_http/Header.html">Header</a>&gt; <strong>getHeaders</strong>(HttpRequest xmlHttp) <a class="anchor-link" href="#getHeaders"
              title="Permalink to Request.getHeaders">#</a></h4>
<div class="doc">
<p>Returns an array of headers built by parsing the string of headers returned
by the JavaScript &lt;code>XmlHttpRequest&lt;/code> object.</p>
<p>@param xmlHttpRequest
@return array of Header items</p>
<pre class="source">
static List&lt;Header&gt; getHeaders(dart_html.HttpRequest xmlHttp) {
 String allHeaders = xmlHttp.getAllResponseHeaders();
 List&lt;String&gt; unparsedHeaders = allHeaders.split("\n");
 List&lt;Header&gt; parsedHeaders = new List&lt;Header&gt;(unparsedHeaders.length);

 for (int i = 0, n = unparsedHeaders.length; i &lt; n; ++i) {
   String unparsedHeader = unparsedHeaders[i];

   if (unparsedHeader.length == 0) {
     continue;
   }

   int endOfNameIdx = unparsedHeader.indexOf(':');
   if (endOfNameIdx &lt; 0) {
     continue;
   }

   String name = unparsedHeader.substring(0, endOfNameIdx).trim();
   String value = unparsedHeader.substring(endOfNameIdx + 1).trim();
   Header header = new _RequestHeader(name, value);

   parsedHeaders[i] = header;
 }

 return parsedHeaders;
}
</pre>
</div>
</div>
<div class="method"><h4 id="isResponseReady">
<button class="show-code">Code</button>
bool <strong>isResponseReady</strong>(HttpRequest xhr) <a class="anchor-link" href="#isResponseReady"
              title="Permalink to Request.isResponseReady">#</a></h4>
<div class="doc">
<pre class="source">
static bool isResponseReady(dart_html.HttpRequest xhr) {
 return xhr.readyState == dart_html.HttpRequest.DONE;
}
</pre>
</div>
</div>
</div>
<div>
<h3>Constructors</h3>
<div class="method"><h4 id="Request">
<button class="show-code">Code</button>
new <strong>Request</strong>(HttpRequest xmlHttpRequest, int timeoutMillis, <a href="../dart_web_toolkit_http/RequestCallback.html">RequestCallback</a> callback) <a class="anchor-link" href="#Request"
              title="Permalink to Request.Request">#</a></h4>
<div class="doc">
<p>Constructs an instance of the Request object.</p>
<p>@param xmlHttpRequest JavaScript XmlHttpRequest object instance
@param timeoutMillis number of milliseconds to wait for a response
@param callback callback interface to use for notification</p>
<p>@throws IllegalArgumentException if timeoutMillis &lt; 0
@throws NullPointerException if xmlHttpRequest, or callback are null</p>
<pre class="source">
Request(dart_html.HttpRequest xmlHttpRequest, int timeoutMillis, RequestCallback callback) {
 if (xmlHttpRequest == null) {
   throw new Exception();
 }

 if (callback == null) {
   throw new Exception();
 }

 if (timeoutMillis &lt; 0) {
   throw new Exception();
 }

 this._timeoutMillis = timeoutMillis;

 this._xmlHttpRequest = xmlHttpRequest;

 if (timeoutMillis &gt; 0) {
   // create and start a Timer
   _timer = new dart_async.Timer(new Duration(milliseconds:timeoutMillis), (){
     _fireOnTimeout(callback);
   });
 } else {
   // no Timer required
   _timer = null;
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="Request.internal">
<button class="show-code">Code</button>
new <strong>Request.internal</strong>() <a class="anchor-link" href="#Request.internal"
              title="Permalink to Request.Request.internal">#</a></h4>
<div class="doc">
<p>Only used for building a
{@link com.google.gwt.user.client.rpc.impl.FailedRequest}.</p>
<pre class="source">
Request.internal();
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method"><h4 id="cancel">
<button class="show-code">Code</button>
void <strong>cancel</strong>() <a class="anchor-link" href="#cancel"
              title="Permalink to Request.cancel">#</a></h4>
<div class="doc">
<p>Cancels a pending request. If the request has already been canceled or if
it has timed out no action is taken.</p>
<pre class="source">
void cancel() {
 /*
  * There is a strange race condition that occurs on Mozilla when you cancel
  * a request while the response is coming in. It appears that in some cases
  * the onreadystatechange handler is still called after the handler function
  * has been deleted and during the call to XmlHttpRequest.abort(). So we
  * null the xmlHttpRequest here and that will prevent the
  * fireOnResponseReceived method from calling the callback function.
  *
  * Setting the onreadystatechange handler to null gives us the correct
  * behavior in Mozilla but crashes IE. That is why we have chosen to fixed
  * this in Java by nulling out our reference to the XmlHttpRequest object.
  */
 if (_xmlHttpRequest != null) {
   dart_html.HttpRequest xmlHttp = _xmlHttpRequest;
   _xmlHttpRequest = null;

   //xmlHttp.onReadyStateChange. readyStateChangeEvent.addListener(listener); // clearOnReadyStateChange();
   xmlHttp.onReadyStateChange.listen(null, onError:null, onDone:null, unsubscribeOnError:true);
   xmlHttp.abort();

   _cancelTimer();
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="fireOnResponseReceived">
<button class="show-code">Code</button>
void <strong>fireOnResponseReceived</strong>(<a href="../dart_web_toolkit_http/RequestCallback.html">RequestCallback</a> callback) <a class="anchor-link" href="#fireOnResponseReceived"
              title="Permalink to Request.fireOnResponseReceived">#</a></h4>
<div class="doc">
<pre class="source">
void fireOnResponseReceived(RequestCallback callback) {
 if (_xmlHttpRequest == null) {
   // the request has timed out at this point
   return;
 }

 _cancelTimer();

 /*
  * We cannot use cancel here because it would clear the contents of the
  * JavaScript XmlHttpRequest object so we manually null out our reference to
  * the JavaScriptObject
  */
 dart_html.HttpRequest xhr = _xmlHttpRequest;
 _xmlHttpRequest = null;

 String errorMsg = _getBrowserSpecificFailure(xhr);
 if (errorMsg != null) {
   Exception exception = new Exception(errorMsg);
   callback.onError(this, exception);
 } else {
   Response response = createResponse(xhr);
   callback.onResponseReceived(this, response);
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="isPending">
<button class="show-code">Code</button>
bool <strong>isPending</strong>() <a class="anchor-link" href="#isPending"
              title="Permalink to Request.isPending">#</a></h4>
<div class="doc">
<p>Returns true if this request is waiting for a response.</p>
<p>@return true if this request is waiting for a response</p>
<pre class="source">
bool isPending() {
 if (_xmlHttpRequest == null) {
   return false;
 }

 int readyState = _xmlHttpRequest.readyState;

 /*
  * Because we are doing asynchronous requests it is possible that we can
  * call XmlHttpRequest.send and still have the XmlHttpRequest.getReadyState
  * method return the state as XmlHttpRequest.OPEN. That is why we include
  * open although it is nottechnically true since open implies that the
  * request has not been sent.
  */
 switch (readyState) {
   case dart_html.HttpRequest.OPENED:
   case dart_html.HttpRequest.HEADERS_RECEIVED:
   case dart_html.HttpRequest.LOADING:
     return true;
 }

 return false;
}
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          <div>This page was generated at 2013-05-06 21:15:14.458</div>
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        
