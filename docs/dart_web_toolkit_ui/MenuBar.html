        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>MenuBar class / dart_web_toolkit_ui Library / API Reference / Dart Web Toolkit</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        <script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-40672112-1']);
  _gaq.push(['_setDomainName', 'dartwebtoolkit.com']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
</head>
        <body data-library="dart_web_toolkit_ui" data-type="MenuBar">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">API Reference 0.3.8+2</a>
         &rsaquo; <a href="../dart_web_toolkit_ui.html">dart_web_toolkit_ui</a> &rsaquo; <a href="../dart_web_toolkit_ui/MenuBar.html">MenuBar</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>MenuBar</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<p>A standard menu bar widget. A menu bar can contain any number of menu items,
each of which can either fire a {@link com.google.gwt.core.client.Scheduler.ScheduledCommand} or
open a cascaded menu bar.</p><p>
<img class='gallery' src='doc-files/MenuBar.png'/>
</p><h3>CSS Style Rules</h3>
<dl>
<dt>.gwt-MenuBar</dt>
<dd>the menu bar itself</dd>
<dt>.gwt-MenuBar-horizontal</dt>
<dd>dependent style applied to horizontal menu bars</dd>
<dt>.gwt-MenuBar-vertical</dt>
<dd>dependent style applied to vertical menu bars</dd>
<dt>.gwt-MenuBar .gwt-MenuItem</dt>
<dd>menu items</dd>
<dt>.gwt-MenuBar .gwt-MenuItem-selected</dt>
<dd>selected menu items</dd>
<dt>.gwt-MenuBar .gwt-MenuItemSeparator</dt>
<dd>section breaks between menu items</dd>
<dt>.gwt-MenuBar .gwt-MenuItemSeparator .menuSeparatorInner</dt>
<dd>inner component of section separators</dd>
<dt>.gwt-MenuBarPopup .menuPopupTopLeft</dt>
<dd>the top left cell</dd>
<dt>.gwt-MenuBarPopup .menuPopupTopLeftInner</dt>
<dd>the inner element of the cell</dd>
<dt>.gwt-MenuBarPopup .menuPopupTopCenter</dt>
<dd>the top center cell</dd>
<dt>.gwt-MenuBarPopup .menuPopupTopCenterInner</dt>
<dd>the inner element of the cell</dd>
<dt>.gwt-MenuBarPopup .menuPopupTopRight</dt>
<dd>the top right cell</dd>
<dt>.gwt-MenuBarPopup .menuPopupTopRightInner</dt>
<dd>the inner element of the cell</dd>
<dt>.gwt-MenuBarPopup .menuPopupMiddleLeft</dt>
<dd>the middle left cell</dd>
<dt>.gwt-MenuBarPopup .menuPopupMiddleLeftInner</dt>
<dd>the inner element of the cell</dd>
<dt>.gwt-MenuBarPopup .menuPopupMiddleCenter</dt>
<dd>the middle center cell</dd>
<dt>.gwt-MenuBarPopup .menuPopupMiddleCenterInner</dt>
<dd>the inner element of the cell</dd>
<dt>.gwt-MenuBarPopup .menuPopupMiddleRight</dt>
<dd>the middle right cell</dd>
<dt>.gwt-MenuBarPopup .menuPopupMiddleRightInner</dt>
<dd>the inner element of the cell</dd>
<dt>.gwt-MenuBarPopup .menuPopupBottomLeft</dt>
<dd>the bottom left cell</dd>
<dt>.gwt-MenuBarPopup .menuPopupBottomLeftInner</dt>
<dd>the inner element of the cell</dd>
<dt>.gwt-MenuBarPopup .menuPopupBottomCenter</dt>
<dd>the bottom center cell</dd>
<dt>.gwt-MenuBarPopup .menuPopupBottomCenterInner</dt>
<dd>the inner element of the cell</dd>
<dt>.gwt-MenuBarPopup .menuPopupBottomRight</dt>
<dd>the bottom right cell</dd>
<dt>.gwt-MenuBarPopup .menuPopupBottomRightInner</dt>
<dd>the inner element of the cell</dd>
</dl><p>
<h3>Example</h3>
{@example com.google.gwt.examples.MenuBarExample}
</p><h3>Use in UiBinder Templates</h3>
<p>
MenuBar elements in UiBinder template files can have a <code>vertical</code>
bool attribute (which defaults to false), and may have only MenuItem
elements as children. MenuItems may contain HTML and MenuBars.
<p>
For example:<pre>
&lt;g:MenuBar>
  &lt;g:MenuItem>Higgledy
    &lt;g:MenuBar vertical="true">
      &lt;g:MenuItem>able&lt;/g:MenuItem>
      &lt;g:MenuItem>baker&lt;/g:MenuItem>
      &lt;g:MenuItem>charlie&lt;/g:MenuItem>
    &lt;/g:MenuBar>
  &lt;/g:MenuItem>
  &lt;g:MenuItem>Piggledy
    &lt;g:MenuBar vertical="true">
      &lt;g:MenuItem>foo&lt;/g:MenuItem>
      &lt;g:MenuItem>bar&lt;/g:MenuItem>
      &lt;g:MenuItem>baz&lt;/g:MenuItem>
    &lt;/g:MenuBar>
  &lt;/g:MenuItem>
  &lt;g:MenuItem>&lt;b>Pop!&lt;/b>
    &lt;g:MenuBar vertical="true">
      &lt;g:MenuItem>uno&lt;/g:MenuItem>
      &lt;g:MenuItem>dos&lt;/g:MenuItem>
      &lt;g:MenuItem>tres&lt;/g:MenuItem>
    &lt;/g:MenuBar>
  &lt;/g:MenuItem>
&lt;/g:MenuBar>
</pre>
<pre class="source">
class MenuBar extends Widget implements HasAnimation, HasCloseHandlers&lt;PopupPanel&gt; {

 static final String _STYLENAME_DEFAULT = "dwt-MenuBar";

 /**
  * List of all {@link MenuItem}s and {@link MenuItemSeparator}s.
  */
 List&lt;UiObject&gt; _allItems = new List&lt;UiObject&gt;();

 /**
  * List of {@link MenuItem}s, not including {@link MenuItemSeparator}s.
  */
 List&lt;MenuItem&gt; _items = new List&lt;MenuItem&gt;();

 dart_html.Element _body;

 AbstractImagePrototype _subMenuIcon = null;
 bool _isAnimationEnabled = false;
 MenuBar _parentMenu;
 PopupPanel _popup;
 MenuItem _selectedItem;
 MenuBar _shownChildMenu;
 bool _vertical = false, _autoOpen = false;
 bool _focusOnHover = true;

 /**
  * Creates an empty menu bar that uses the specified ClientBundle for menu
  * images.
  *
  * @param vertical &lt;code&gt;true&lt;/code&gt; to orient the menu bar vertically
  * @param resources a bundle that provides images for this menu
  */
 MenuBar([bool vertical = false, MenuResource resources = null]) {
   if (resources == null) {
     resources = new MenuResources();
   }
   _init(vertical, AbstractImagePrototype.create(resources.menuBarSubMenuIcon()));
 }

 HandlerRegistration addCloseHandler(CloseHandler&lt;PopupPanel&gt; handler) {
   return addHandler(handler, CloseEvent.TYPE);
 }

 /**
  * Adds a menu item to the bar.
  *
  * @param item the item to be added
  * @return the {@link MenuItem} object
  */
 MenuItem addItem(MenuItem item) {
   return insertItem(item, _allItems.length);
 }

 /**
  * Adds a menu item to the bar containing SafeHtml, that will fire the given
  * command when it is selected.
  *
  * @param html the item's html text
  * @param cmd the command to be fired
  * @return the {@link MenuItem} object created
  */
 MenuItem addSafeHtmlItem(SafeHtml html, {MenuBar popup, ScheduledCommand cmd}) {
   return addItem(new MenuItem.fromSafeHtml(html, subMenu:popup, cmd:cmd));
 }

 /**
  * Adds a menu item to the bar, that will fire the given command when it is
  * selected.
  *
  * @param text the item's text
  * @param asHtml &lt;code&gt;true&lt;/code&gt; to treat the specified text as html
  * @param cmd the command to be fired
  * @return the {@link MenuItem} object created
  */
 MenuItem addTextItem(String text, bool asHtml, {MenuBar popup, ScheduledCommand cmd}) {
   return addItem(new MenuItem(text, asHtml, subMenu:popup, cmd:cmd));
 }

 /**
  * Adds a thin line to the {@link MenuBar} to separate sections of
  * {@link MenuItem}s.
  *
  * @param separator the {@link MenuItemSeparator} to be added
  * @return the {@link MenuItemSeparator} object
  */
 MenuItemSeparator addSeparator([MenuItemSeparator separator = null]) {
   if (separator == null) {
     separator = new MenuItemSeparator();
   }
   return insertSeparator(_allItems.length, separator);
 }

 /**
  * Removes all menu items from this menu bar.
  */
 void clearItems() {
   // Deselect the current item
   selectItem(null);

   dart_html.Element container = _getItemContainerElement();
   while (Dom.getChildCount(container) &gt; 0) {
     Dom.getChild(container, 0).remove();
   }

   // Set the parent of all items to null
   for (UiObject item in _allItems) {
     _setItemColSpan(item, 1);
     if (item is MenuItemSeparator) {
       (item as MenuItemSeparator).setParentMenu(null);
     } else {
       (item as MenuItem).setParentMenu(null);
     }
   }

   // Clear out all of the items and separators
   _items.clear();
   _allItems.clear();
 }

 /**
  * Closes this menu and all child menu popups.
  *
  * @param pFocus true to move focus to the parent
  */
 void closeAllChildren(bool pFocus) {
   if (_shownChildMenu != null) {
     // Hide any open submenus of this item
     _shownChildMenu._onHide(pFocus);
     _shownChildMenu = null;
     selectItem(null);
   }
   // Close the current popup
   if (_popup != null) {
     _popup.hide();
   }
   // If focus is true, set focus to parentMenu
   if (pFocus &amp;&amp; _parentMenu != null) {
     _parentMenu.focus();
   }
 }

 /**
  * Give this MenuBar focus.
  */
 void focus() {
   FocusPanel.impl.focus(getElement());
 }

 /**
  * Gets whether this menu bar's child menus will open when the mouse is moved
  * over it.
  *
  * @return &lt;code&gt;true&lt;/code&gt; if child menus will auto-open
  */
 bool getAutoOpen() {
   return _autoOpen;
 }

 /**
  * Get the index of a {@link MenuItem}.
  *
  * @return the index of the item, or -1 if it is not contained by this MenuBar
  */
 int getItemIndex(MenuItem item) {
   return _allItems.indexOf(item);
 }

 /**
  * Get the index of a {@link MenuItemSeparator}.
  *
  * @return the index of the separator, or -1 if it is not contained by this
  *         MenuBar
  */
 int getSeparatorIndex(MenuItemSeparator item) {
   return _allItems.indexOf(item);
 }

 /**
  * Adds a menu item to the bar at a specific index.
  *
  * @param item the item to be inserted
  * @param beforeIndex the index where the item should be inserted
  * @return the {@link MenuItem} object
  * @throws IndexOutOfBoundsException if &lt;code&gt;beforeIndex&lt;/code&gt; is out of
  *           range
  */
 MenuItem insertItem(MenuItem item, int beforeIndex) {
   // Check the bounds
   if (beforeIndex &lt; 0 || beforeIndex &gt; _allItems.length) {
     throw new Exception("IndexOutOfBounds");
   }

   // Add to the list of items
//    _allItems.insertRange(beforeIndex, 1, item);
   _allItems.insert(beforeIndex, item);
   int itemsIndex = 0;
   for (int i = 0; i &lt; beforeIndex; i++) {
     if (_allItems[i] is MenuItem) {
       itemsIndex++;
     }
   }
//    _items.insertRange(itemsIndex, 1, item);
   _items.insert(itemsIndex, item);

   // Setup the menu item
   _addItemElement(beforeIndex, item.getElement());
   item.setParentMenu(this);
   item.setSelectionStyle(false);
   updateSubmenuIcon(item);
   return item;
 }

 /**
  * Adds a thin line to the {@link MenuBar} to separate sections of
  * {@link MenuItem}s at the specified index.
  *
  * @param separator the {@link MenuItemSeparator} to be inserted
  * @param beforeIndex the index where the separator should be inserted
  * @return the {@link MenuItemSeparator} object
  * @throws IndexOutOfBoundsException if &lt;code&gt;beforeIndex&lt;/code&gt; is out of
  *           range
  */
 MenuItemSeparator insertSeparator(int beforeIndex, [MenuItemSeparator separator = null]) {
   // Check the bounds
   if (beforeIndex &lt; 0 || beforeIndex &gt; _allItems.length) {
     throw new Exception("IndexOutOfBounds");
   }

   if (separator == null) {
     separator = new MenuItemSeparator();
   }

   if (_vertical) {
     _setItemColSpan(separator, 2);
   }
   _addItemElement(beforeIndex, separator.getElement());
   separator.setParentMenu(this);
//    _allItems.insertRange(beforeIndex, 1, separator);
   _allItems.insert(beforeIndex, separator);
   return separator;
 }


 bool isAnimationEnabled() {
   return _isAnimationEnabled;
 }

 /**
  * Check whether or not this widget will steal keyboard focus when the mouse
  * hovers over it.
  *
  * @return true if enabled, false if disabled
  */
 bool isFocusOnHoverEnabled() {
   return _focusOnHover;
 }

 /**
  * Moves the menu selection down to the next item. If there is no selection,
  * selects the first item. If there are no items at all, does nothing.
  */
 void moveSelectionDown() {
   if (_selectFirstItemIfNoneSelected()) {
     return;
   }

   if (_vertical) {
     _selectNextItem();
   } else {
     if (_selectedItem.getSubMenu() != null
         &amp;&amp; !_selectedItem.getSubMenu().getItems().isEmpty
         &amp;&amp; (_shownChildMenu == null || _shownChildMenu.getSelectedItem() == null)) {
       if (_shownChildMenu == null) {
         doItemAction(_selectedItem, false, true);
       }
       _selectedItem.getSubMenu().focus();
     } else if (_parentMenu != null) {
       if (_parentMenu._vertical) {
         _parentMenu._selectNextItem();
       } else {
         _parentMenu.moveSelectionDown();
       }
     }
   }
 }

 /**
  * Moves the menu selection up to the previous item. If there is no selection,
  * selects the first item. If there are no items at all, does nothing.
  */
 void moveSelectionUp() {
   if (_selectFirstItemIfNoneSelected()) {
     return;
   }

   if ((_shownChildMenu == null) &amp;&amp; _vertical) {
     _selectPrevItem();
   } else if ((_parentMenu != null) &amp;&amp; _parentMenu._vertical) {
     _parentMenu._selectPrevItem();
   } else {
     _close(true);
   }
 }


 void onBrowserEvent(dart_html.Event event) {
   MenuItem item = _findItem(event.target);
   switch (Dom.eventGetType(event)) {
     case IEvent.ONCLICK:
       FocusPanel.impl.focus(getElement());
       // Fire an item's command when the user clicks on it.
       if (item != null) {
         doItemAction(item, true, true);
       }
       break;

     case IEvent.ONMOUSEOVER:
       if (item != null) {
         itemOver(item, true);
       }
       break;

     case IEvent.ONMOUSEOUT:
       if (item != null) {
         itemOver(null, true);
       }
       break;

     case IEvent.ONFOCUS:
       _selectFirstItemIfNoneSelected();
       break;

     case IEvent.ONKEYDOWN:
       dart_html.KeyboardEvent kEvent = event as dart_html.KeyboardEvent;
       int keyCode = kEvent.keyCode;
       switch (keyCode) {
         case KeyCodes.KEY_LEFT:
           if (LocaleInfo.getCurrentLocale().isRTL()) {
             _moveToNextItem();
           } else {
             _moveToPrevItem();
           }
           _eatEvent(event);
           break;
         case KeyCodes.KEY_RIGHT:
           if (LocaleInfo.getCurrentLocale().isRTL()) {
             _moveToPrevItem();
           } else {
             _moveToNextItem();
           }
           _eatEvent(event);
           break;
         case KeyCodes.KEY_UP:
           moveSelectionUp();
           _eatEvent(event);
           break;
         case KeyCodes.KEY_DOWN:
           moveSelectionDown();
           _eatEvent(event);
           break;
         case KeyCodes.KEY_ESCAPE:
           closeAllParentsAndChildren();
           _eatEvent(event);
           break;
         case KeyCodes.KEY_TAB:
           closeAllParentsAndChildren();
           break;
         case KeyCodes.KEY_ENTER:
           if (!_selectFirstItemIfNoneSelected()) {
             doItemAction(_selectedItem, true, true);
             _eatEvent(event);
           }
           break;
       } // end switch(keyCode)

       break;
   } // end switch (Dom.eventGetType(event))
   super.onBrowserEvent(event);
 }

 /**
  * Closes the menu bar.
  *
  * @deprecated Use {@link #addCloseHandler(CloseHandler)} instead
  */
//
//  @Deprecated
//  void onPopupClosed(PopupPanel sender, bool autoClosed) {
//    // If the menu popup was auto-closed, close all of its parents as well.
//    if (autoClosed) {
//      closeAllParents();
//    }
//
//    // When the menu popup closes, remember that no item is
//    // currently showing a popup menu.
//    onHide(!autoClosed);
//    CloseEvent.fire(MenuBar.this, sender);
//    shownChildMenu = null;
//    popup = null;
//    if (parentMenu != null &amp;&amp; parentMenu.popup != null) {
//      parentMenu.popup.setPreviewingAllNativeEvents(true);
//    }
//  }

 /**
  * Removes the specified menu item from the bar.
  *
  * @param item the item to be removed
  */
 void removeItem(MenuItem item) {
   // Unselect if the item is currently selected
   if (_selectedItem == item) {
     selectItem(null);
   }

   if (_removeItemElement(item)) {
     _setItemColSpan(item, 1);
     _items.remove(item);
     item.setParentMenu(null);
   }
 }

 /**
  * Removes the specified {@link MenuItemSeparator} from the bar.
  *
  * @param separator the separator to be removed
  */
 void removeSeparator(MenuItemSeparator separator) {
   if (_removeItemElement(separator)) {
     separator.setParentMenu(null);
   }
 }

 /**
  * Select the given MenuItem, which must be a direct child of this MenuBar.
  *
  * @param item the MenuItem to select, or null to clear selection
  */
 void selectItem(MenuItem item) {
   assert (item == null || item.getParentMenu() == this);

   if (item == _selectedItem) {
     return;
   }

   if (_selectedItem != null) {
     _selectedItem.setSelectionStyle(false);
     // Set the style of the submenu indicator
     if (_vertical) {
       dart_html.Element tr = _selectedItem.getElement().parent;
       if (Dom.getChildCount(tr) == 2) {
         dart_html.Element td = Dom.getChild(tr, 1);
         UiObject.manageElementStyleName(td, "subMenuIcon-selected", false);
       }
     }
   }

   if (item != null) {
     item.setSelectionStyle(true);

     // Set the style of the submenu indicator
     if (_vertical) {
       dart_html.Element tr = item.getElement().parent;
       if (tr.children.length == 2) {
         dart_html.Element td = tr.children[1];
         UiObject.manageElementStyleName(td, "subMenuIcon-selected", true);
       }
     }

//      Roles.getMenubarRole().setAriaActivedescendantProperty(getElement(),
//          IdReference.of(Dom.getElementAttribute(item.getElement(), "id")));
   }

   _selectedItem = item;
 }


 void setAnimationEnabled(bool enable) {
   _isAnimationEnabled = enable;
 }

 /**
  * Sets whether this menu bar's child menus will open when the mouse is moved
  * over it.
  *
  * @param autoOpen &lt;code&gt;true&lt;/code&gt; to cause child menus to auto-open
  */
 void setAutoOpen(bool autoOpen) {
   this._autoOpen = autoOpen;
 }

 /**
  * Enable or disable auto focus when the mouse hovers over the MenuBar. This
  * allows the MenuBar to respond to keyboard events without the user having to
  * click on it, but it will steal focus from other elements on the page.
  * Enabled by default.
  *
  * @param enabled true to enable, false to disable
  */
 void setFocusOnHoverEnabled(bool enabled) {
   _focusOnHover = enabled;
 }

 /**
  * Returns a list containing the &lt;code&gt;MenuItem&lt;/code&gt; objects in the menu
  * bar. If there are no items in the menu bar, then an empty &lt;code&gt;List&lt;/code&gt;
  * object will be returned.
  *
  * @return a list containing the &lt;code&gt;MenuItem&lt;/code&gt; objects in the menu bar
  */
 List&lt;MenuItem&gt; getItems() {
   return this._items;
 }

 /**
  * Returns the &lt;code&gt;MenuItem&lt;/code&gt; that is currently selected (highlighted)
  * by the user. If none of the items in the menu are currently selected, then
  * &lt;code&gt;null&lt;/code&gt; will be returned.
  *
  * @return the &lt;code&gt;MenuItem&lt;/code&gt; that is currently selected, or
  *         &lt;code&gt;null&lt;/code&gt; if no items are currently selected
  */
 MenuItem getSelectedItem() {
   return this._selectedItem;
 }


 void onDetach() {
   // When the menu is detached, make sure to close all of its children.
   if (_popup != null) {
     _popup.hide();
   }

   super.onDetach();
 }

 /*
  * Closes all parent menu popups.
  */
 void closeAllParents() {
   if (_parentMenu != null) {
     // The parent menu will recursively call closeAllParents.
     _close(false);
   } else {
     // If this is the top most menu, deselect the current item.
     selectItem(null);
   }
 }

 /**
  * Closes all parent and child menu popups.
  */
 void closeAllParentsAndChildren() {
   closeAllParents();
   // Ensure the popup is closed even if it has not been enetered
   // with the mouse or key navigation
   if (_parentMenu == null &amp;&amp; _popup != null) {
     _popup.hide();
   }
 }

 /*
  * Performs the action associated with the given menu item. If the item has a
  * popup associated with it, the popup will be shown. If it has a command
  * associated with it, and 'fireCommand' is true, then the command will be
  * fired. Popups associated with other items will be hidden.
  *
  * @param item the item whose popup is to be shown. @param fireCommand
  * &lt;code&gt;true&lt;/code&gt; if the item's command should be fired, &lt;code&gt;false&lt;/code&gt;
  * otherwise.
  */
 void doItemAction(final MenuItem item, bool fireCommand, bool pFocus) {
   // Should not perform any action if the item is disabled
   if (!item.enabled) {
     return;
   }

   // Ensure that the item is selected.
   selectItem(item);

   // if the command should be fired and the item has one, fire it
   if (fireCommand &amp;&amp; item.getScheduledCommand() != null) {
     // Close this menu and all of its parents.
     closeAllParents();

     // Fire the item's command. The command must be fired in the same event
     // loop or popup blockers will prevent popups from opening.
     ScheduledCommand cmd = item.getScheduledCommand();
     Scheduler.get().scheduleDeferred(new _MenuScheduledCommand(cmd));

     // hide any open submenus of this item
     if (_shownChildMenu != null) {
       _shownChildMenu._onHide(pFocus);
       _popup.hide();
       _shownChildMenu = null;
       selectItem(null);
     }
   } else if (item.getSubMenu() != null) {
     if (_shownChildMenu == null) {
       // open this submenu
       _openPopup(item);
     } else if (item.getSubMenu() != _shownChildMenu) {
       // close the other submenu and open this one
       _shownChildMenu._onHide(pFocus);
       _popup.hide();
       _openPopup(item);
     } else if (fireCommand &amp;&amp; !_autoOpen) {
       // close this submenu
       _shownChildMenu._onHide(pFocus);
       _popup.hide();
       _shownChildMenu = null;
       selectItem(item);
     }
   } else if (_autoOpen &amp;&amp; _shownChildMenu != null) {
     // close submenu
     _shownChildMenu._onHide(pFocus);
     _popup.hide();
     _shownChildMenu = null;
   }
 }

 /**
  * Visible for testing.
  */
 PopupPanel getPopup() {
   return _popup;
 }

 void itemOver(MenuItem item, bool pFocus) {
   if (item == null) {
     // Don't clear selection if the currently selected item's menu is showing.
     if ((_selectedItem != null)
         &amp;&amp; (_shownChildMenu == _selectedItem.getSubMenu())) {
       return;
     }
   }

   if (item != null &amp;&amp; !item.enabled) {
     return;
   }

   // Style the item selected when the mouse enters.
   selectItem(item);
   if (pFocus &amp;&amp; _focusOnHover) {
     focus();
   }

   // If child menus are being shown, or this menu is itself
   // a child menu, automatically show an item's child menu
   // when the mouse enters.
   if (item != null) {
     if ((_shownChildMenu != null) || (_parentMenu != null) || _autoOpen) {
       doItemAction(item, false, _focusOnHover);
     }
   }
 }

//  /**
//   * Set the IDs of the menu items.
//   *
//   * @param baseID the base ID
//   */
//  void setMenuItemDebugIds(String baseID) {
//    int itemCount = 0;
//    for (MenuItem item in _items) {
//      item.ensureDebugId(baseID + "-item" + itemCount);
//      itemCount++;
//    }
//  }

 /**
  * Show or hide the icon used for items with a submenu.
  *
  * @param item the item with or without a submenu
  */
 void updateSubmenuIcon(MenuItem item) {
   // The submenu icon only applies to vertical menus
   if (!_vertical) {
     return;
   }

   // Get the index of the MenuItem
   int idx = _allItems.indexOf(item);
   if (idx == -1) {
     return;
   }

   dart_html.Element container = _getItemContainerElement();
   dart_html.Element tr = Dom.getChild(container, idx);
   int tdCount = Dom.getChildCount(tr);
   MenuBar submenu = item.getSubMenu();
   if (submenu == null) {
     // Remove the submenu indicator
     if (tdCount == 2) {
       //Dom.removeChild(tr, Dom.getChild(tr, 1));
       Dom.getChild(tr, 1).remove();
     }
     _setItemColSpan(item, 2);
   } else if (tdCount == 1) {
     // Show the submenu indicator
     _setItemColSpan(item, 1);
     dart_html.Element td = new dart_html.TableCellElement();
     td.style.verticalAlign = "middle";
     td.append(_subMenuIcon.createElement());
     UiObject.setElementStyleName(td, "subMenuIcon");
     tr.append(td);
   }
 }

 /**
  * Physically add the td element of a {@link MenuItem} or
  * {@link MenuItemSeparator} to this {@link MenuBar}.
  *
  * @param beforeIndex the index where the separator should be inserted
  * @param tdElem the td element to be added
  */
 void _addItemElement(int beforeIndex, dart_html.Element tdElem) {
   if (_vertical) {
     dart_html.Element tr = new dart_html.TableRowElement();
     Dom.insertChild(_body, tr, beforeIndex);
     tr.append(tdElem);
   } else {
     dart_html.Element tr = Dom.getChild(_body, 0);
     Dom.insertChild(tr, tdElem, beforeIndex);
   }
 }

 /**
  * Closes this menu (if it is a popup).
  *
  * @param focus true to move focus to the parent
  */
 void _close(bool focus) {
   if (_parentMenu != null) {
     _parentMenu._popup.hide(!focus);
     if (focus) {
       _parentMenu.focus();
     }
   }
 }

 void _eatEvent(dart_html.Event event) {
   event.cancelBubble = true;
   event.preventDefault();
 }

 MenuItem _findItem(dart_html.Element hItem) {
   for (MenuItem item in _items) {
     if (Dom.isOrHasChild(item.getElement(), hItem)) {
       return item;
     }
   }
   return null;
 }

 dart_html.Element _getItemContainerElement() {
   if (_vertical) {
     return _body;
   } else {
     return Dom.getChild(_body, 0);
   }
 }

 void _init(bool vertical, AbstractImagePrototype subMenuIcon) {
   this._subMenuIcon = subMenuIcon;

   dart_html.TableElement table = new dart_html.TableElement();
   _body = table.createTBody();
   table.append(_body);

   if (!vertical) {
     dart_html.Element tr = new dart_html.TableRowElement();
     _body.append(tr);
   }

   this._vertical = vertical;

   dart_html.Element outer = FocusPanel.impl.createFocusable();
   outer.append(table);
   setElement(outer);

   //Roles.getMenubarRole().set(getElement());

   sinkEvents(IEvent.ONCLICK | IEvent.ONMOUSEOVER | IEvent.ONMOUSEOUT
       | IEvent.ONFOCUS | IEvent.ONKEYDOWN);

   clearAndSetStyleName(_STYLENAME_DEFAULT);
   if (_vertical) {
     addStyleDependentName("vertical");
   } else {
     addStyleDependentName("horizontal");
   }

   // Hide focus outline in Mozilla/Webkit/Opera
   Dom.setStyleAttribute(getElement(), "outline", "0px");

   // Hide focus outline in IE 6/7
   Dom.setElementAttribute(getElement(), "hideFocus", "true");

   // Deselect items when blurring without a child menu.
   addDomHandler(new BlurHandlerAdapter((BlurEvent evt) {
     if (_shownChildMenu == null) {
       selectItem(null);
     }
   }), BlurEvent.TYPE);
 }

 void _moveToNextItem() {
   if (_selectFirstItemIfNoneSelected()) {
     return;
   }

   if (!_vertical) {
     _selectNextItem();
   } else {
     if (_selectedItem.getSubMenu() != null
         &amp;&amp; !_selectedItem.getSubMenu().getItems().isEmpty
         &amp;&amp; (_shownChildMenu == null || _shownChildMenu.getSelectedItem() == null)) {
       if (_shownChildMenu == null) {
         doItemAction(_selectedItem, false, true);
       }
       _selectedItem.getSubMenu().focus();
     } else if (_parentMenu != null) {
       if (!_parentMenu._vertical) {
         _parentMenu._selectNextItem();
       } else {
         _parentMenu._moveToNextItem();
       }
     }
   }
 }

 void _moveToPrevItem() {
   if (_selectFirstItemIfNoneSelected()) {
     return;
   }

   if (!_vertical) {
     _selectPrevItem();
   } else {
     if ((_parentMenu != null) &amp;&amp; (!_parentMenu._vertical)) {
       _parentMenu._selectPrevItem();
     } else {
       _close(true);
     }
   }
 }

 /*
  * This method is called when a menu bar is hidden, so that it can hide any
  * child popups that are currently being shown.
  */
 void _onHide(bool pFocus) {
   if (_shownChildMenu != null) {
     _shownChildMenu._onHide(pFocus);
     _popup.hide();
     if (pFocus) {
       focus();
     }
   }
 }

 /*
  * This method is called when a menu bar is shown.
  */
 void _onShow() {
   // clear the selection; a keyboard user can cursor down to the first item
   selectItem(null);
 }

 void _openPopup(MenuItem item) {
   // Only the last popup to be opened should preview all event
   if (_parentMenu != null &amp;&amp; _parentMenu._popup != null) {
     _parentMenu._popup.setPreviewingAllNativeEvents(false);
   }

   // Create a new popup for this item, and position it next to
   // the item (below if this is a horizontal menu bar, to the
   // right if it's a vertical bar).
   _popup = new _MenuDecoratedPopupPanel(this, item, true, false, "menuPopup");
   _popup.setAnimationType(AnimationType.ONE_WAY_CORNER);
   _popup.setAnimationEnabled(_isAnimationEnabled);
   _popup.clearAndSetStyleName(_STYLENAME_DEFAULT + "Popup");
   String primaryStyleName = getStylePrimaryName();
   if (_STYLENAME_DEFAULT != primaryStyleName) {
     _popup.addStyleName(primaryStyleName + "Popup");
   }
   //_popup.addPopupListener(this);
   // Closes the menu bar.
   _popup.addCloseHandler(new CloseHandlerAdapter((CloseEvent evt){
       // If the menu popup was auto-closed, close all of its parents as well.
       if (evt.autoClosed) {
         closeAllParents();
       }

       // When the menu popup closes, remember that no item is
       // currently showing a popup menu.
       _onHide(!evt.autoClosed);
       CloseEvent.fire(this, evt.target);
       _shownChildMenu = null;
       _popup = null;
       if (_parentMenu != null &amp;&amp; _parentMenu._popup != null) {
         _parentMenu._popup.setPreviewingAllNativeEvents(true);
       }
   }));

   _shownChildMenu = item.getSubMenu();
   item.getSubMenu()._parentMenu = this;

   // Show the popup, ensuring that the menubar's event preview remains on top
   // of the popup's.
   _popup.setPopupPositionAndShow(new _PopupPanelPositionCallback(this, item));
 }

 /**
  * Removes the specified item from the {@link MenuBar} and the physical Dom
  * structure.
  *
  * @param item the item to be removed
  * @return true if the item was removed
  */
 bool _removeItemElement(UiObject item) {
   int idx = _allItems.indexOf(item);
   if (idx == -1) {
     return false;
   }

   dart_html.Element container = _getItemContainerElement();
   //Dom.removeChild(container, Dom.getChild(container, idx));
   Dom.getChild(container, idx).remove();
   _allItems.remove(idx);
   return true;
 }

 /**
  * Selects the first item in the menu if no items are currently selected. Has
  * no effect if there are no items.
  *
  * @return true if no item was previously selected, false otherwise
  */
 bool _selectFirstItemIfNoneSelected() {
   if (_selectedItem == null) {
     for (MenuItem nextItem in _items) {
       if (nextItem.enabled) {
         selectItem(nextItem);
         break;
       }
     }
     return true;
   }
   return false;
}

 void _selectNextItem() {
   if (_selectedItem == null) {
     return;
   }

   int index = _items.indexOf(_selectedItem);
   // We know that selectedItem is set to an item that is contained in the
   // items collection.
   // Therefore, we know that index can never be -1.
   assert (index != -1);

   MenuItem itemToBeSelected;

   int firstIndex = index;
   while (true) {
     index = index + 1;
     if (index == _items.length) {
       // we're at the end, loop around to the start
       index = 0;
     }
     if (index == firstIndex) {
       itemToBeSelected = _items[firstIndex];
       break;
     } else {
       itemToBeSelected = _items[index];
       if (itemToBeSelected.enabled) {
         break;
       }
     }
   }

   selectItem(itemToBeSelected);
   if (_shownChildMenu != null) {
     doItemAction(itemToBeSelected, false, true);
   }
 }

 void _selectPrevItem() {
   if (_selectedItem == null) {
     return;
   }

   int index = _items.indexOf(_selectedItem);
   // We know that selectedItem is set to an item that is contained in the
   // items collection.
   // Therefore, we know that index can never be -1.
   assert (index != -1);

   MenuItem itemToBeSelected;

   int firstIndex = index;
   while (true) {
     index = index - 1;
     if (index &lt; 0) {
       // we're at the start, loop around to the end
       index = _items.length - 1;
     }
     if (index == firstIndex) {
       itemToBeSelected = _items[firstIndex];
       break;
     } else {
       itemToBeSelected = _items[index];
       if (itemToBeSelected.enabled) {
         break;
       }
     }
   }

   selectItem(itemToBeSelected);
   if (_shownChildMenu != null) {
     doItemAction(itemToBeSelected, false, true);
   }
 }

 /**
  * Set the colspan of a {@link MenuItem} or {@link MenuItemSeparator}.
  *
  * @param item the {@link MenuItem} or {@link MenuItemSeparator}
  * @param colspan the colspan
  */
 void _setItemColSpan(UiObject item, int colspan) {
   Dom.setElementPropertyInt(item.getElement(), "colSpan", colspan);
 }
}
</pre>
</div>
<h3>Extends</h3>
<p>
<span class="type-box"><span class="icon-class"></span><a href="../dart_web_toolkit_ui/UiObject.html">UiObject</a></span>&nbsp;&gt;&nbsp;<span class="type-box"><span class="icon-class"></span><a href="../dart_web_toolkit_ui/Widget.html">Widget</a></span>&nbsp;&gt;&nbsp;<span class="type-box"><span class="icon-class"></span><strong>MenuBar</strong></span></p>
<h3>Implements</h3>
<p>
<span class="type-box"><span class="icon-class"></span><a href="../dart_web_toolkit_event/HasCloseHandlers.html">HasCloseHandlers&lt;PopupPanel&gt;</a></span>, <span class="type-box"><span class="icon-class"></span><a href="../dart_web_toolkit_event/HasAnimation.html">HasAnimation</a></span></p>
<div>
<h3>Constructors</h3>
<div class="method"><h4 id="MenuBar">
<button class="show-code">Code</button>
new <strong>MenuBar</strong>([bool vertical = false, <a href="../dart_web_toolkit_ui/MenuResource.html">MenuResource</a> resources = null]) <a class="anchor-link" href="#MenuBar"
              title="Permalink to MenuBar.MenuBar">#</a></h4>
<div class="doc">
<p>Creates an empty menu bar that uses the specified ClientBundle for menu
images.</p>
<p>@param vertical &lt;code>true&lt;/code> to orient the menu bar vertically
@param resources a bundle that provides images for this menu</p>
<pre class="source">
MenuBar([bool vertical = false, MenuResource resources = null]) {
 if (resources == null) {
   resources = new MenuResources();
 }
 _init(vertical, AbstractImagePrototype.create(resources.menuBarSubMenuIcon()));
}
</pre>
</div>
</div>
</div>
<div class="inherited">
<h3>Properties</h3>
<div class="field inherited"><h4 id="eventsToSink">
<button class="show-code">Code</button>
int         <strong>eventsToSink</strong> <a class="anchor-link"
            href="#eventsToSink"
            title="Permalink to MenuBar.eventsToSink">#</a>
        </h4>
        <div class="inherited-from">inherited from <a href="../dart_web_toolkit_ui/Widget.html">Widget</a> </div><div class="doc">
<p>A set og events that should be sunk when the widget is attached to
the DOM. (We delay the sinking of events to improve startup performance.)
When the widget is attached, this is set is empty</p>
<p>Package protected to allow Composite to see it.</p>
<pre class="source">
int eventsToSink = 0
</pre>
</div>
</div>
<div class="method inherited"><h4 id="title">
<button class="show-code">Code</button>
String <strong>get title</strong> <a class="anchor-link" href="#title"
              title="Permalink to MenuBar.get title">#</a></h4>
<div class="inherited-from">inherited from <a href="../dart_web_toolkit_ui/UiObject.html">UiObject</a> </div><div class="doc">
<p>Gets the title associated with this object. The title is the 'tool-tip'
displayed to users when they hover over the object.</p>
<p>@return the object's title</p>
<pre class="source">
String get title =&gt; getElement().title;
</pre>
</div>
</div>
<div class="method inherited"><h4 id="title=">
<button class="show-code">Code</button>
void <strong>set title</strong>(String value) <a class="anchor-link" href="#title="
              title="Permalink to MenuBar.set title">#</a></h4>
<div class="inherited-from">inherited from <a href="../dart_web_toolkit_ui/UiObject.html">UiObject</a> </div><div class="doc">
<p>Sets the element's title.</p>
<pre class="source">
void set title(String value) {
 getElement().title = value;
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="visible">
<button class="show-code">Code</button>
bool <strong>get visible</strong> <a class="anchor-link" href="#visible"
              title="Permalink to MenuBar.get visible">#</a></h4>
<div class="inherited-from">inherited from <a href="../dart_web_toolkit_ui/UiObject.html">UiObject</a> </div><div class="doc">
<p>Determines whether or not this object is visible. Note that this does not
necessarily take into account whether or not the receiver's parent is
visible, or even if it is attached to the
<code>Document</code>. The default implementation of this trait in <code>UIObject</code> is
based on the value of a dom element's style object's display attribute.</p>
<p>@return &lt;code>true&lt;/code> if the object is visible</p>
<pre class="source">
bool get visible =&gt; isVisible(getElement());
</pre>
</div>
</div>
<div class="method inherited"><h4 id="visible=">
<button class="show-code">Code</button>
void <strong>set visible</strong>(bool visible) <a class="anchor-link" href="#visible="
              title="Permalink to MenuBar.set visible">#</a></h4>
<div class="inherited-from">inherited from <a href="../dart_web_toolkit_ui/UiObject.html">UiObject</a> </div><div class="doc">
<p>Sets whether this object is visible.</p>
<p>@param visible &lt;code>true&lt;/code> to show the object, &lt;code>false&lt;/code> to</p>
<pre><code>     hide it
</code></pre>
<pre class="source">
void set visible(bool visible) {
 setVisible(getElement(), visible);
}
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method inherited"><h4 id="addAttachHandler">
<button class="show-code">Code</button>
<a href="../dart_web_toolkit_event/HandlerRegistration.html">HandlerRegistration</a> <strong>addAttachHandler</strong>(<a href="../dart_web_toolkit_event/AttachEventHandler.html">AttachEventHandler</a> handler) <a class="anchor-link" href="#addAttachHandler"
              title="Permalink to MenuBar.addAttachHandler">#</a></h4>
<div class="inherited-from">inherited from <a href="../dart_web_toolkit_ui/Widget.html">Widget</a> </div><div class="doc">
<p>Adds an <code>AttachEvent</code> handler.</p>
<p>@param handler the handler
@return the handler registration</p>
<pre class="source">
HandlerRegistration addAttachHandler(AttachEventHandler handler) {
 return addHandler(handler, AttachEvent.TYPE);
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="addBitlessDomHandler">
<button class="show-code">Code</button>
<a href="../dart_web_toolkit_event/HandlerRegistration.html">HandlerRegistration</a> <strong>addBitlessDomHandler</strong>(<a href="../dart_web_toolkit_event/EventHandler.html">EventHandler</a> handler, <a href="../dart_web_toolkit_event/DomEventType.html">DomEventType</a> type) <a class="anchor-link" href="#addBitlessDomHandler"
              title="Permalink to MenuBar.addBitlessDomHandler">#</a></h4>
<div class="inherited-from">inherited from <a href="../dart_web_toolkit_ui/Widget.html">Widget</a> </div><div class="doc">
<p>For &lt;a href=
"http://code.google.com/p/google-web-toolkit/wiki/UnderstandingMemoryLeaks"</p>
<blockquote>
<p>browsers which do not leak&lt;/a>, adds a native event handler to the widget.</p></blockquote>
<p>Note that, unlike the
{@link #addDomHandler(EventHandler, com.google.gwt.event.dom.client.DomEvent.Type)}
implementation, there is no need to attach the widget to the DOM in order
to cause the event handlers to be attached.</p>
<p>@param &lt;H> the type of handler to add
@param type the event key
@param handler the handler
@return {@link HandlerRegistration} used to remove the handler</p>
<pre class="source">
HandlerRegistration addBitlessDomHandler(EventHandler handler, DomEventType type) {
 assert (handler != null);; // : "handler must not be null";
 assert (type != null); // : "type must not be null";
 sinkBitlessEvent(type.eventName);
 return ensureHandlers().addHandler(type, handler);
}
</pre>
</div>
</div>
<div class="method"><h4 id="addCloseHandler">
<button class="show-code">Code</button>
<a href="../dart_web_toolkit_event/HandlerRegistration.html">HandlerRegistration</a> <strong>addCloseHandler</strong>(<a href="../dart_web_toolkit_event/CloseHandler.html">CloseHandler</a>&lt;<a href="../dart_web_toolkit_ui/PopupPanel.html">PopupPanel</a>&gt; handler) <a class="anchor-link" href="#addCloseHandler"
              title="Permalink to MenuBar.addCloseHandler">#</a></h4>
<div class="doc">
<div class="inherited">
<p>Adds a {@link CloseEvent} handler.</p>
<p>@param handler the handler
@return the registration for the event</p>
<div class="docs-inherited-from">docs inherited from <a href="../dart_web_toolkit_event/HasCloseHandlers.html">HasCloseHandlers</a>&lt;<a href="../dart_web_toolkit_ui/PopupPanel.html">PopupPanel</a>&gt; </div></div>
<pre class="source">
HandlerRegistration addCloseHandler(CloseHandler&lt;PopupPanel&gt; handler) {
 return addHandler(handler, CloseEvent.TYPE);
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="addDomHandler">
<button class="show-code">Code</button>
<a href="../dart_web_toolkit_event/HandlerRegistration.html">HandlerRegistration</a> <strong>addDomHandler</strong>(<a href="../dart_web_toolkit_event/EventHandler.html">EventHandler</a> handler, <a href="../dart_web_toolkit_event/DomEventType.html">DomEventType</a> type) <a class="anchor-link" href="#addDomHandler"
              title="Permalink to MenuBar.addDomHandler">#</a></h4>
<div class="inherited-from">inherited from <a href="../dart_web_toolkit_ui/Widget.html">Widget</a> </div><div class="doc">
<p>Adds a native event handler to the widget and sinks the corresponding
native event. If you do not want to sink the native event, use the generic
addHandler method instead.</p>
<p>@param &lt;H> the type of handler to add
@param type the event key
@param handler the handler
@return {@link HandlerRegistration} used to remove the handler</p>
<pre class="source">
HandlerRegistration addDomHandler(EventHandler handler, DomEventType type) {
 assert (handler != null); // : "handler must not be null";
 assert (type != null); // : "type must not be null";
 int typeInt = IEvent.getTypeInt(type.eventName);
 if (typeInt == -1) {
   sinkBitlessEvent(type.eventName);
 } else {
   sinkEvents(typeInt);
 }
 return ensureHandlers().addHandler(type, handler);
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="addHandler">
<button class="show-code">Code</button>
<a href="../dart_web_toolkit_event/HandlerRegistration.html">HandlerRegistration</a> <strong>addHandler</strong>(<a href="../dart_web_toolkit_event/EventHandler.html">EventHandler</a> handler, <a href="../dart_web_toolkit_event/EventType.html">EventType</a>&lt;<a href="../dart_web_toolkit_event/EventHandler.html">EventHandler</a>&gt; type) <a class="anchor-link" href="#addHandler"
              title="Permalink to MenuBar.addHandler">#</a></h4>
<div class="inherited-from">inherited from <a href="../dart_web_toolkit_ui/Widget.html">Widget</a> </div><div class="doc">
<p>Adds this handler to the widget.</p>
<p>@param &lt;H> the type of handler to add
@param type the event type
@param handler the handler
@return {@link HandlerRegistration} used to remove the handler</p>
<pre class="source">
HandlerRegistration addHandler(EventHandler handler, EventType&lt;EventHandler&gt; type) {
 return ensureHandlers().addHandler(type, handler);
}
</pre>
</div>
</div>
<div class="method"><h4 id="addItem">
<button class="show-code">Code</button>
<a href="../dart_web_toolkit_ui/MenuItem.html">MenuItem</a> <strong>addItem</strong>(<a href="../dart_web_toolkit_ui/MenuItem.html">MenuItem</a> item) <a class="anchor-link" href="#addItem"
              title="Permalink to MenuBar.addItem">#</a></h4>
<div class="doc">
<p>Adds a menu item to the bar.</p>
<p>@param item the item to be added
@return the {@link MenuItem} object</p>
<pre class="source">
MenuItem addItem(MenuItem item) {
 return insertItem(item, _allItems.length);
}
</pre>
</div>
</div>
<div class="method"><h4 id="addSafeHtmlItem">
<button class="show-code">Code</button>
<a href="../dart_web_toolkit_ui/MenuItem.html">MenuItem</a> <strong>addSafeHtmlItem</strong>(<a href="../dart_web_toolkit_util/SafeHtml.html">SafeHtml</a> html, {<a href="../dart_web_toolkit_ui/MenuBar.html">MenuBar</a> popup, <a href="../dart_web_toolkit_scheduler/ScheduledCommand.html">ScheduledCommand</a> cmd}) <a class="anchor-link" href="#addSafeHtmlItem"
              title="Permalink to MenuBar.addSafeHtmlItem">#</a></h4>
<div class="doc">
<p>Adds a menu item to the bar containing SafeHtml, that will fire the given
command when it is selected.</p>
<p>@param html the item's html text
@param cmd the command to be fired
@return the {@link MenuItem} object created</p>
<pre class="source">
MenuItem addSafeHtmlItem(SafeHtml html, {MenuBar popup, ScheduledCommand cmd}) {
 return addItem(new MenuItem.fromSafeHtml(html, subMenu:popup, cmd:cmd));
}
</pre>
</div>
</div>
<div class="method"><h4 id="addSeparator">
<button class="show-code">Code</button>
<a href="../dart_web_toolkit_ui/MenuItemSeparator.html">MenuItemSeparator</a> <strong>addSeparator</strong>([<a href="../dart_web_toolkit_ui/MenuItemSeparator.html">MenuItemSeparator</a> separator = null]) <a class="anchor-link" href="#addSeparator"
              title="Permalink to MenuBar.addSeparator">#</a></h4>
<div class="doc">
<p>Adds a thin line to the {@link MenuBar} to separate sections of
{@link MenuItem}s.</p>
<p>@param separator the {@link MenuItemSeparator} to be added
@return the {@link MenuItemSeparator} object</p>
<pre class="source">
MenuItemSeparator addSeparator([MenuItemSeparator separator = null]) {
 if (separator == null) {
   separator = new MenuItemSeparator();
 }
 return insertSeparator(_allItems.length, separator);
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="addStyleDependentName">
<button class="show-code">Code</button>
void <strong>addStyleDependentName</strong>(String styleSuffix) <a class="anchor-link" href="#addStyleDependentName"
              title="Permalink to MenuBar.addStyleDependentName">#</a></h4>
<div class="inherited-from">inherited from <a href="../dart_web_toolkit_ui/UiObject.html">UiObject</a> </div><div class="doc">
<p>Adds a dependent style name by specifying the style name's suffix. The
actual form of the style name that is added is:</p><pre class="code">
getStylePrimaryName() + '-' + styleSuffix
</pre>
<p>@param styleSuffix the suffix of the dependent style to be added.
@see #setStylePrimaryName(String)
@see #removeStyleDependentName(String)
@see #setStyleDependentName(String, boolean)
@see #addStyleName(String)</p>
<pre class="source">
void addStyleDependentName(String styleSuffix) {
 setStyleDependentName(styleSuffix, true);
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="addStyleName">
<button class="show-code">Code</button>
void <strong>addStyleName</strong>(String style) <a class="anchor-link" href="#addStyleName"
              title="Permalink to MenuBar.addStyleName">#</a></h4>
<div class="inherited-from">inherited from <a href="../dart_web_toolkit_ui/UiObject.html">UiObject</a> </div><div class="doc">
<p>Adds a secondary or dependent style name to this object. A secondary style
name is an additional style name that is, in HTML/CSS terms, included as a
space-separated token in the value of the CSS &lt;code>class&lt;/code> attribute
for this object's root element.</p><p>
The most important use for this method is to add a special kind of
secondary style name called a <i>dependent style name</i>. To add a
dependent style name, use {@link #addStyleDependentName(String)}, which
will prefix the 'style' argument with the result of
{@link #k()} (followed by a '-'). For example, suppose
the primary style name is <code>gwt-TextBox</code>. If the following method
is called as <code>obj.setReadOnly(true)</code>:
</p><pre class="code">
public void setReadOnly(boolean readOnly) {
  isReadOnlyMode = readOnly;
<p>  // Create a dependent style name.
  String readOnlyStyle = "readonly";</p>
<p>  if (readOnly) {</p>
<pre><code>addStyleDependentName(readOnlyStyle);
</code></pre>
<p>  } else {</p>
<pre><code>removeStyleDependentName(readOnlyStyle);
</code></pre>
<p>  }
}&lt;/pre></p><p>
then both of the CSS style rules below will be applied:
</p><pre class="code">
<p>// This rule is based on the primary style name and is always active.
.gwt-TextBox {
  font-size: 12pt;
}</p>
<p>// This rule is based on a dependent style name that is only active
// when the widget has called addStyleName(getStylePrimaryName() +
// "-readonly").
.gwt-TextBox-readonly {
  background-color: lightgrey;
  border: none;
}&lt;/pre></p><p>
The code can also be simplified with
{@link #setStyleDependentName(String, boolean)}:
</p><pre class="code">
public void setReadOnly(boolean readOnly) {
  isReadOnlyMode = readOnly;
  setStyleDependentName("readonly", readOnly);
}</pre><p>
Dependent style names are powerful because they are automatically updated
whenever the primary style name changes. Continuing with the example above,
if the primary style name changed due to the following call:
</p><pre class="code">setStylePrimaryName("my-TextThingy");</pre><p>
then the object would be re-associated with following style rules, removing
those that were shown above.
</p><pre class="code">
.my-TextThingy {
  font-size: 20pt;
}
<p>.my-TextThingy-readonly {
  background-color: red;
  border: 2px solid yellow;
}&lt;/pre></p><p>
Secondary style names that are not dependent style names are not
automatically updated when the primary style name changes.
</p>
<p>@param style the secondary style name to be added
@see UIObject
@see #removeStyleName(String)</p>
<pre class="source">
void addStyleName(String style) {
 setStyleName(style, true);
}
</pre>
</div>
</div>
<div class="method"><h4 id="addTextItem">
<button class="show-code">Code</button>
<a href="../dart_web_toolkit_ui/MenuItem.html">MenuItem</a> <strong>addTextItem</strong>(String text, bool asHtml, {<a href="../dart_web_toolkit_ui/MenuBar.html">MenuBar</a> popup, <a href="../dart_web_toolkit_scheduler/ScheduledCommand.html">ScheduledCommand</a> cmd}) <a class="anchor-link" href="#addTextItem"
              title="Permalink to MenuBar.addTextItem">#</a></h4>
<div class="doc">
<p>Adds a menu item to the bar, that will fire the given command when it is
selected.</p>
<p>@param text the item's text
@param asHtml &lt;code>true&lt;/code> to treat the specified text as html
@param cmd the command to be fired
@return the {@link MenuItem} object created</p>
<pre class="source">
MenuItem addTextItem(String text, bool asHtml, {MenuBar popup, ScheduledCommand cmd}) {
 return addItem(new MenuItem(text, asHtml, subMenu:popup, cmd:cmd));
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="asWidget">
<button class="show-code">Code</button>
<a href="../dart_web_toolkit_ui/Widget.html">Widget</a> <strong>asWidget</strong>() <a class="anchor-link" href="#asWidget"
              title="Permalink to MenuBar.asWidget">#</a></h4>
<div class="inherited-from">inherited from <a href="../dart_web_toolkit_ui/Widget.html">Widget</a> </div><div class="doc">
<p>Returns the <a class="crossref" href="../dart_web_toolkit_ui/Widget.html">Widget</a> aspect of the receiver.</p>
<pre class="source">
Widget asWidget() {
 return this;
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="clearAndSetStyleName">
<button class="show-code">Code</button>
void <strong>clearAndSetStyleName</strong>(String style) <a class="anchor-link" href="#clearAndSetStyleName"
              title="Permalink to MenuBar.clearAndSetStyleName">#</a></h4>
<div class="inherited-from">inherited from <a href="../dart_web_toolkit_ui/UiObject.html">UiObject</a> </div><div class="doc">
<p>Clears all of the object's style names and sets it to the given style. You
should normally use {@link #setStylePrimaryName(String)} unless you wish to
explicitly remove all existing styles.</p>
<p>@param style the new style name
@see #setStylePrimaryName(String)</p>
<pre class="source">
void clearAndSetStyleName(String style) {
 setElementStyleName(getStyleElement(), style);
}
</pre>
</div>
</div>
<div class="method"><h4 id="clearItems">
<button class="show-code">Code</button>
void <strong>clearItems</strong>() <a class="anchor-link" href="#clearItems"
              title="Permalink to MenuBar.clearItems">#</a></h4>
<div class="doc">
<p>Removes all menu items from this menu bar.</p>
<pre class="source">
void clearItems() {
 // Deselect the current item
 selectItem(null);

 dart_html.Element container = _getItemContainerElement();
 while (Dom.getChildCount(container) &gt; 0) {
   Dom.getChild(container, 0).remove();
 }

 // Set the parent of all items to null
 for (UiObject item in _allItems) {
   _setItemColSpan(item, 1);
   if (item is MenuItemSeparator) {
     (item as MenuItemSeparator).setParentMenu(null);
   } else {
     (item as MenuItem).setParentMenu(null);
   }
 }

 // Clear out all of the items and separators
 _items.clear();
 _allItems.clear();
}
</pre>
</div>
</div>
<div class="method"><h4 id="closeAllChildren">
<button class="show-code">Code</button>
void <strong>closeAllChildren</strong>(bool pFocus) <a class="anchor-link" href="#closeAllChildren"
              title="Permalink to MenuBar.closeAllChildren">#</a></h4>
<div class="doc">
<p>Closes this menu and all child menu popups.</p>
<p>@param pFocus true to move focus to the parent</p>
<pre class="source">
void closeAllChildren(bool pFocus) {
 if (_shownChildMenu != null) {
   // Hide any open submenus of this item
   _shownChildMenu._onHide(pFocus);
   _shownChildMenu = null;
   selectItem(null);
 }
 // Close the current popup
 if (_popup != null) {
   _popup.hide();
 }
 // If focus is true, set focus to parentMenu
 if (pFocus &amp;&amp; _parentMenu != null) {
   _parentMenu.focus();
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="closeAllParents">
<button class="show-code">Code</button>
void <strong>closeAllParents</strong>() <a class="anchor-link" href="#closeAllParents"
              title="Permalink to MenuBar.closeAllParents">#</a></h4>
<div class="doc">
<pre class="source">
void closeAllParents() {
 if (_parentMenu != null) {
   // The parent menu will recursively call closeAllParents.
   _close(false);
 } else {
   // If this is the top most menu, deselect the current item.
   selectItem(null);
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="closeAllParentsAndChildren">
<button class="show-code">Code</button>
void <strong>closeAllParentsAndChildren</strong>() <a class="anchor-link" href="#closeAllParentsAndChildren"
              title="Permalink to MenuBar.closeAllParentsAndChildren">#</a></h4>
<div class="doc">
<p>Closes all parent and child menu popups.</p>
<pre class="source">
void closeAllParentsAndChildren() {
 closeAllParents();
 // Ensure the popup is closed even if it has not been enetered
 // with the mouse or key navigation
 if (_parentMenu == null &amp;&amp; _popup != null) {
   _popup.hide();
 }
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="createEventBus">
<button class="show-code">Code</button>
<a href="../dart_web_toolkit_event/EventBus.html">EventBus</a> <strong>createEventBus</strong>() <a class="anchor-link" href="#createEventBus"
              title="Permalink to MenuBar.createEventBus">#</a></h4>
<div class="inherited-from">inherited from <a href="../dart_web_toolkit_ui/Widget.html">Widget</a> </div><div class="doc">
<p>Creates the <code>SimpleEventBus</code> used by this Widget. You can override
this method to create a custom <code>EventBus</code>.</p>
<p>@return the <code>EventBus</code> you want to use.</p>
<pre class="source">
EventBus createEventBus() {
 return new SimpleEventBus();
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="delegateEvent">
<button class="show-code">Code</button>
void <strong>delegateEvent</strong>(<a href="../dart_web_toolkit_ui/Widget.html">Widget</a> target, <a href="../dart_web_toolkit_event/DwtEvent.html">DwtEvent</a> event) <a class="anchor-link" href="#delegateEvent"
              title="Permalink to MenuBar.delegateEvent">#</a></h4>
<div class="inherited-from">inherited from <a href="../dart_web_toolkit_ui/Widget.html">Widget</a> </div><div class="doc">
<p>Fires an event on a child widget. Used to delegate the handling of an event
from one widget to another.</p>
<p>@param event the event
@param target fire the event on the given target</p>
<pre class="source">
void delegateEvent(Widget target, DwtEvent event) {
 target.fireEvent(event);
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="doAttachChildren">
<button class="show-code">Code</button>
void <strong>doAttachChildren</strong>() <a class="anchor-link" href="#doAttachChildren"
              title="Permalink to MenuBar.doAttachChildren">#</a></h4>
<div class="inherited-from">inherited from <a href="../dart_web_toolkit_ui/Widget.html">Widget</a> </div><div class="doc">
<p>If a widget contains one or more child widgets that are not in the logical
widget hierarchy (the child is physically connected only on the DOM level),
it must override this method and call {@link #onAttach()} for each of its
child widgets.</p>
<p>@see #onAttach()</p>
<pre class="source">
void doAttachChildren() {
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="doDetachChildren">
<button class="show-code">Code</button>
void <strong>doDetachChildren</strong>() <a class="anchor-link" href="#doDetachChildren"
              title="Permalink to MenuBar.doDetachChildren">#</a></h4>
<div class="inherited-from">inherited from <a href="../dart_web_toolkit_ui/Widget.html">Widget</a> </div><div class="doc">
<p>If a widget contains one or more child widgets that are not in the logical
widget hierarchy (the child is physically connected only on the DOM level),
it must override this method and call {@link #onDetach()} for each of its
child widgets.</p>
<p>@see #onDetach()</p>
<pre class="source">
void doDetachChildren() {
}
</pre>
</div>
</div>
<div class="method"><h4 id="doItemAction">
<button class="show-code">Code</button>
void <strong>doItemAction</strong>(<a href="../dart_web_toolkit_ui/MenuItem.html">MenuItem</a> item, bool fireCommand, bool pFocus) <a class="anchor-link" href="#doItemAction"
              title="Permalink to MenuBar.doItemAction">#</a></h4>
<div class="doc">
<pre class="source">
void doItemAction(final MenuItem item, bool fireCommand, bool pFocus) {
 // Should not perform any action if the item is disabled
 if (!item.enabled) {
   return;
 }

 // Ensure that the item is selected.
 selectItem(item);

 // if the command should be fired and the item has one, fire it
 if (fireCommand &amp;&amp; item.getScheduledCommand() != null) {
   // Close this menu and all of its parents.
   closeAllParents();

   // Fire the item's command. The command must be fired in the same event
   // loop or popup blockers will prevent popups from opening.
   ScheduledCommand cmd = item.getScheduledCommand();
   Scheduler.get().scheduleDeferred(new _MenuScheduledCommand(cmd));

   // hide any open submenus of this item
   if (_shownChildMenu != null) {
     _shownChildMenu._onHide(pFocus);
     _popup.hide();
     _shownChildMenu = null;
     selectItem(null);
   }
 } else if (item.getSubMenu() != null) {
   if (_shownChildMenu == null) {
     // open this submenu
     _openPopup(item);
   } else if (item.getSubMenu() != _shownChildMenu) {
     // close the other submenu and open this one
     _shownChildMenu._onHide(pFocus);
     _popup.hide();
     _openPopup(item);
   } else if (fireCommand &amp;&amp; !_autoOpen) {
     // close this submenu
     _shownChildMenu._onHide(pFocus);
     _popup.hide();
     _shownChildMenu = null;
     selectItem(item);
   }
 } else if (_autoOpen &amp;&amp; _shownChildMenu != null) {
   // close submenu
   _shownChildMenu._onHide(pFocus);
   _popup.hide();
   _shownChildMenu = null;
 }
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="ensureHandlers">
<button class="show-code">Code</button>
<a href="../dart_web_toolkit_event/EventBus.html">EventBus</a> <strong>ensureHandlers</strong>() <a class="anchor-link" href="#ensureHandlers"
              title="Permalink to MenuBar.ensureHandlers">#</a></h4>
<div class="inherited-from">inherited from <a href="../dart_web_toolkit_ui/Widget.html">Widget</a> </div><div class="doc">
<p>Ensures the existence of the event bus.</p>
<p>@return the <code>EventBus</code>.</p>
<pre class="source">
EventBus ensureHandlers() {
 return _eventBus == null ? _eventBus = createEventBus() : _eventBus;
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="extractLengthValue">
<button class="show-code">Code</button>
double <strong>extractLengthValue</strong>(String s) <a class="anchor-link" href="#extractLengthValue"
              title="Permalink to MenuBar.extractLengthValue">#</a></h4>
<div class="inherited-from">inherited from <a href="../dart_web_toolkit_ui/UiObject.html">UiObject</a> </div><div class="doc">
<p>Intended to be used to pull the value out of a CSS length. If the
value is "auto" or "inherit", 0 will be returned.</p>
<p>@param s The CSS length string to extract
@return The leading numeric portion of &lt;code>s&lt;/code>, or 0 if "auto" or</p>
<pre><code>    "inherit" are passed in.
</code></pre>
<pre class="source">
double extractLengthValue(String s) {
 if (s == "auto" || s == "inherit" || s == "") {
   return 0.0;
 } else {
   // numberRegex divides the string into a leading numeric portion
   // followed by an arbitrary portion.
   if(numberRegex.hasMatch(s)) {
     // Extract the leading numeric portion of string
     s = numberRegex.firstMatch(s)[0];
   }
   return double.parse(s);
 }
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="fireEvent">
<button class="show-code">Code</button>
void <strong>fireEvent</strong>(<a href="../dart_web_toolkit_event/DwtEvent.html">DwtEvent</a> event) <a class="anchor-link" href="#fireEvent"
              title="Permalink to MenuBar.fireEvent">#</a></h4>
<div class="inherited-from">inherited from <a href="../dart_web_toolkit_ui/Widget.html">Widget</a> </div><div class="doc">
<p>Fires the given event to the handlers listening to the event's type.</p>
<p>Any exceptions thrown by handlers will be bundled into a
<code>UmbrellaException</code> and then re-thrown after all handlers have
completed. An exception thrown by a handler will not prevent other handlers
from executing.</p>
<p>@param event the event</p>
<pre class="source">
void fireEvent(DwtEvent event) {
//    if (_eventBus != null) {
//      _eventBus.fireEvent(event);
//    }
 if (_eventBus != null) {
   // If it not live we should revive it.
   if (!event.isLive()) {
     event.revive();
   }
   Object oldSource = event.getSource();
   event.overrideSource(getElement());
   try {

     // May throw an UmbrellaException.
     _eventBus.fireEventFromSource(event, getElement());
   } on UmbrellaException catch (e) {
     throw new UmbrellaException(e.causes);
   } finally {
     if (oldSource == null) {
       // This was my event, so I should kill it now that I'm done.
       event.kill();
     } else {
       // Restoring the source for the next handler to use.
       event.overrideSource(oldSource);
     }
   }
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="focus">
<button class="show-code">Code</button>
void <strong>focus</strong>() <a class="anchor-link" href="#focus"
              title="Permalink to MenuBar.focus">#</a></h4>
<div class="doc">
<p>Give this MenuBar focus.</p>
<pre class="source">
void focus() {
 FocusPanel.impl.focus(getElement());
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="getAbsoluteLeft">
<button class="show-code">Code</button>
int <strong>getAbsoluteLeft</strong>() <a class="anchor-link" href="#getAbsoluteLeft"
              title="Permalink to MenuBar.getAbsoluteLeft">#</a></h4>
<div class="inherited-from">inherited from <a href="../dart_web_toolkit_ui/UiObject.html">UiObject</a> </div><div class="doc">
<p>Gets the object's absolute left position in pixels, as measured from the
browser window's client area.</p>
<p>@return the object's absolute left position</p>
<pre class="source">
int getAbsoluteLeft() {
 return Dom.getAbsoluteLeft(getElement());
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="getAbsoluteTop">
<button class="show-code">Code</button>
int <strong>getAbsoluteTop</strong>() <a class="anchor-link" href="#getAbsoluteTop"
              title="Permalink to MenuBar.getAbsoluteTop">#</a></h4>
<div class="inherited-from">inherited from <a href="../dart_web_toolkit_ui/UiObject.html">UiObject</a> </div><div class="doc">
<p>Gets the object's absolute top position in pixels, as measured from the
browser window's client area.</p>
<p>@return the object's absolute top position</p>
<pre class="source">
int getAbsoluteTop() {
 return Dom.getAbsoluteTop(getElement());
}
</pre>
</div>
</div>
<div class="method"><h4 id="getAutoOpen">
<button class="show-code">Code</button>
bool <strong>getAutoOpen</strong>() <a class="anchor-link" href="#getAutoOpen"
              title="Permalink to MenuBar.getAutoOpen">#</a></h4>
<div class="doc">
<p>Gets whether this menu bar's child menus will open when the mouse is moved
over it.</p>
<p>@return &lt;code>true&lt;/code> if child menus will auto-open</p>
<pre class="source">
bool getAutoOpen() {
 return _autoOpen;
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="getElement">
<button class="show-code">Code</button>
Element <strong>getElement</strong>() <a class="anchor-link" href="#getElement"
              title="Permalink to MenuBar.getElement">#</a></h4>
<div class="inherited-from">inherited from <a href="../dart_web_toolkit_ui/UiObject.html">UiObject</a> </div><div class="doc">
<p>Gets this object's browser element.</p>
<pre class="source">
dart_html.Element getElement() {
 assert (_element != null); // : MISSING_ELEMENT_ERROR;
 return _element;
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="getEventBus">
<button class="show-code">Code</button>
<a href="../dart_web_toolkit_event/EventBus.html">EventBus</a> <strong>getEventBus</strong>() <a class="anchor-link" href="#getEventBus"
              title="Permalink to MenuBar.getEventBus">#</a></h4>
<div class="inherited-from">inherited from <a href="../dart_web_toolkit_ui/Widget.html">Widget</a> </div><div class="doc">
<p>Return EventBus.</p>
<pre class="source">
EventBus getEventBus() {
 return _eventBus;
}
</pre>
</div>
</div>
<div class="method"><h4 id="getItemIndex">
<button class="show-code">Code</button>
int <strong>getItemIndex</strong>(<a href="../dart_web_toolkit_ui/MenuItem.html">MenuItem</a> item) <a class="anchor-link" href="#getItemIndex"
              title="Permalink to MenuBar.getItemIndex">#</a></h4>
<div class="doc">
<p>Get the index of a {@link MenuItem}.</p>
<p>@return the index of the item, or -1 if it is not contained by this MenuBar</p>
<pre class="source">
int getItemIndex(MenuItem item) {
 return _allItems.indexOf(item);
}
</pre>
</div>
</div>
<div class="method"><h4 id="getItems">
<button class="show-code">Code</button>
List&lt;<a href="../dart_web_toolkit_ui/MenuItem.html">MenuItem</a>&gt; <strong>getItems</strong>() <a class="anchor-link" href="#getItems"
              title="Permalink to MenuBar.getItems">#</a></h4>
<div class="doc">
<p>Returns a list containing the &lt;code>MenuItem&lt;/code> objects in the menu
bar. If there are no items in the menu bar, then an empty &lt;code>List&lt;/code>
object will be returned.</p>
<p>@return a list containing the &lt;code>MenuItem&lt;/code> objects in the menu bar</p>
<pre class="source">
List&lt;MenuItem&gt; getItems() {
 return this._items;
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="getLayoutData">
<button class="show-code">Code</button>
Object <strong>getLayoutData</strong>() <a class="anchor-link" href="#getLayoutData"
              title="Permalink to MenuBar.getLayoutData">#</a></h4>
<div class="inherited-from">inherited from <a href="../dart_web_toolkit_ui/Widget.html">Widget</a> </div><div class="doc">
<p>Gets the panel-defined layout data associated with this widget.</p>
<p>@return the widget's layout data
@see #setLayoutData</p>
<pre class="source">
Object getLayoutData() {
 return _layoutData;
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="getOffsetHeight">
<button class="show-code">Code</button>
int <strong>getOffsetHeight</strong>() <a class="anchor-link" href="#getOffsetHeight"
              title="Permalink to MenuBar.getOffsetHeight">#</a></h4>
<div class="inherited-from">inherited from <a href="../dart_web_toolkit_ui/UiObject.html">UiObject</a> </div><div class="doc">
<p>Gets the object's offset height in pixels. This is the total height of the
object, including decorations such as border and padding, but not margin.</p>
<p>@return the object's offset height</p>
<pre class="source">
int getOffsetHeight() {
 return getElement().offset.height; // Dom.getElementPropertyInt(getElement(), "offsetHeight");
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="getOffsetWidth">
<button class="show-code">Code</button>
int <strong>getOffsetWidth</strong>() <a class="anchor-link" href="#getOffsetWidth"
              title="Permalink to MenuBar.getOffsetWidth">#</a></h4>
<div class="inherited-from">inherited from <a href="../dart_web_toolkit_ui/UiObject.html">UiObject</a> </div><div class="doc">
<p>Gets the object's offset width in pixels. This is the total width of the
object, including decorations such as border and padding, but not margin.</p>
<p>@return the object's offset width</p>
<pre class="source">
int getOffsetWidth() {
 return getElement().offset.width; // Dom.getElementPropertyInt(getElement(), "offsetWidth");
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="getParent">
<button class="show-code">Code</button>
<a href="../dart_web_toolkit_ui/Widget.html">Widget</a> <strong>getParent</strong>() <a class="anchor-link" href="#getParent"
              title="Permalink to MenuBar.getParent">#</a></h4>
<div class="inherited-from">inherited from <a href="../dart_web_toolkit_ui/Widget.html">Widget</a> </div><div class="doc">
<p>Gets this widget's parent panel.</p>
<p>@return the widget's parent panel</p>
<pre class="source">
Widget getParent() {
 return _parent;
}
</pre>
</div>
</div>
<div class="method"><h4 id="getPopup">
<button class="show-code">Code</button>
<a href="../dart_web_toolkit_ui/PopupPanel.html">PopupPanel</a> <strong>getPopup</strong>() <a class="anchor-link" href="#getPopup"
              title="Permalink to MenuBar.getPopup">#</a></h4>
<div class="doc">
<p>Visible for testing.</p>
<pre class="source">
PopupPanel getPopup() {
 return _popup;
}
</pre>
</div>
</div>
<div class="method"><h4 id="getSelectedItem">
<button class="show-code">Code</button>
<a href="../dart_web_toolkit_ui/MenuItem.html">MenuItem</a> <strong>getSelectedItem</strong>() <a class="anchor-link" href="#getSelectedItem"
              title="Permalink to MenuBar.getSelectedItem">#</a></h4>
<div class="doc">
<p>Returns the &lt;code>MenuItem&lt;/code> that is currently selected (highlighted)
by the user. If none of the items in the menu are currently selected, then
&lt;code>null&lt;/code> will be returned.</p>
<p>@return the &lt;code>MenuItem&lt;/code> that is currently selected, or</p>
<pre><code>    &lt;code&gt;null&lt;/code&gt; if no items are currently selected
</code></pre>
<pre class="source">
MenuItem getSelectedItem() {
 return this._selectedItem;
}
</pre>
</div>
</div>
<div class="method"><h4 id="getSeparatorIndex">
<button class="show-code">Code</button>
int <strong>getSeparatorIndex</strong>(<a href="../dart_web_toolkit_ui/MenuItemSeparator.html">MenuItemSeparator</a> item) <a class="anchor-link" href="#getSeparatorIndex"
              title="Permalink to MenuBar.getSeparatorIndex">#</a></h4>
<div class="doc">
<p>Get the index of a {@link MenuItemSeparator}.</p>
<p>@return the index of the separator, or -1 if it is not contained by this</p>
<pre><code>    MenuBar
</code></pre>
<pre class="source">
int getSeparatorIndex(MenuItemSeparator item) {
 return _allItems.indexOf(item);
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="getStyleElement">
<button class="show-code">Code</button>
Element <strong>getStyleElement</strong>() <a class="anchor-link" href="#getStyleElement"
              title="Permalink to MenuBar.getStyleElement">#</a></h4>
<div class="inherited-from">inherited from <a href="../dart_web_toolkit_ui/UiObject.html">UiObject</a> </div><div class="doc">
<p>Template method that returns the element to which style names will be
applied. By default it returns the root element, but this method may be
overridden to apply styles to a child element.</p>
<p>@return the element to which style names will be applied</p>
<pre class="source">
dart_html.Element getStyleElement() {
 return getElement();
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="getStyleName">
<button class="show-code">Code</button>
String <strong>getStyleName</strong>() <a class="anchor-link" href="#getStyleName"
              title="Permalink to MenuBar.getStyleName">#</a></h4>
<div class="inherited-from">inherited from <a href="../dart_web_toolkit_ui/UiObject.html">UiObject</a> </div><div class="doc">
<p>Gets all of the object's style names, as a space-separated list. If you
wish to retrieve only the primary style name, call
{@link #getStylePrimaryName()}.</p>
<p>@return the objects's space-separated style names
@see #getStylePrimaryName()</p>
<pre class="source">
String getStyleName() {
 return getElementStyleName(getStyleElement());
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="getStylePrimaryName">
<button class="show-code">Code</button>
String <strong>getStylePrimaryName</strong>() <a class="anchor-link" href="#getStylePrimaryName"
              title="Permalink to MenuBar.getStylePrimaryName">#</a></h4>
<div class="inherited-from">inherited from <a href="../dart_web_toolkit_ui/UiObject.html">UiObject</a> </div><div class="doc">
<p>Gets the primary style name associated with the object.</p>
<p>@return the object's primary style name
@see #setStyleName(String)
@see #addStyleName(String)
@see #removeStyleName(String)</p>
<pre class="source">
String getStylePrimaryName() {
 return getElementStylePrimaryName(getStyleElement());
}
</pre>
</div>
</div>
<div class="method"><h4 id="insertItem">
<button class="show-code">Code</button>
<a href="../dart_web_toolkit_ui/MenuItem.html">MenuItem</a> <strong>insertItem</strong>(<a href="../dart_web_toolkit_ui/MenuItem.html">MenuItem</a> item, int beforeIndex) <a class="anchor-link" href="#insertItem"
              title="Permalink to MenuBar.insertItem">#</a></h4>
<div class="doc">
<p>Adds a menu item to the bar at a specific index.</p>
<p>@param item the item to be inserted
@param beforeIndex the index where the item should be inserted
@return the {@link MenuItem} object
@throws IndexOutOfBoundsException if &lt;code>beforeIndex&lt;/code> is out of</p>
<pre><code>      range
</code></pre>
<pre class="source">
MenuItem insertItem(MenuItem item, int beforeIndex) {
 // Check the bounds
 if (beforeIndex &lt; 0 || beforeIndex &gt; _allItems.length) {
   throw new Exception("IndexOutOfBounds");
 }

 // Add to the list of items
//    _allItems.insertRange(beforeIndex, 1, item);
 _allItems.insert(beforeIndex, item);
 int itemsIndex = 0;
 for (int i = 0; i &lt; beforeIndex; i++) {
   if (_allItems[i] is MenuItem) {
     itemsIndex++;
   }
 }
//    _items.insertRange(itemsIndex, 1, item);
 _items.insert(itemsIndex, item);

 // Setup the menu item
 _addItemElement(beforeIndex, item.getElement());
 item.setParentMenu(this);
 item.setSelectionStyle(false);
 updateSubmenuIcon(item);
 return item;
}
</pre>
</div>
</div>
<div class="method"><h4 id="insertSeparator">
<button class="show-code">Code</button>
<a href="../dart_web_toolkit_ui/MenuItemSeparator.html">MenuItemSeparator</a> <strong>insertSeparator</strong>(int beforeIndex, [<a href="../dart_web_toolkit_ui/MenuItemSeparator.html">MenuItemSeparator</a> separator = null]) <a class="anchor-link" href="#insertSeparator"
              title="Permalink to MenuBar.insertSeparator">#</a></h4>
<div class="doc">
<p>Adds a thin line to the {@link MenuBar} to separate sections of
{@link MenuItem}s at the specified index.</p>
<p>@param separator the {@link MenuItemSeparator} to be inserted
@param beforeIndex the index where the separator should be inserted
@return the {@link MenuItemSeparator} object
@throws IndexOutOfBoundsException if &lt;code>beforeIndex&lt;/code> is out of</p>
<pre><code>      range
</code></pre>
<pre class="source">
MenuItemSeparator insertSeparator(int beforeIndex, [MenuItemSeparator separator = null]) {
 // Check the bounds
 if (beforeIndex &lt; 0 || beforeIndex &gt; _allItems.length) {
   throw new Exception("IndexOutOfBounds");
 }

 if (separator == null) {
   separator = new MenuItemSeparator();
 }

 if (_vertical) {
   _setItemColSpan(separator, 2);
 }
 _addItemElement(beforeIndex, separator.getElement());
 separator.setParentMenu(this);
//    _allItems.insertRange(beforeIndex, 1, separator);
 _allItems.insert(beforeIndex, separator);
 return separator;
}
</pre>
</div>
</div>
<div class="method"><h4 id="isAnimationEnabled">
<button class="show-code">Code</button>
bool <strong>isAnimationEnabled</strong>() <a class="anchor-link" href="#isAnimationEnabled"
              title="Permalink to MenuBar.isAnimationEnabled">#</a></h4>
<div class="doc">
<div class="inherited">
<p>Returns true if animations are enabled, false if not.</p>
<div class="docs-inherited-from">docs inherited from <a href="../dart_web_toolkit_event/HasAnimation.html">HasAnimation</a> </div></div>
<pre class="source">
bool isAnimationEnabled() {
 return _isAnimationEnabled;
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="isAttached">
<button class="show-code">Code</button>
bool <strong>isAttached</strong>() <a class="anchor-link" href="#isAttached"
              title="Permalink to MenuBar.isAttached">#</a></h4>
<div class="inherited-from">inherited from <a href="../dart_web_toolkit_ui/Widget.html">Widget</a> </div><div class="doc">
<p>Returns whether or not the receiver is attached to the
{@link com.google.gwt.dom.client.Document Document}'s
{@link com.google.gwt.dom.client.BodyElement BodyElement}.</p>
<p>@return true if attached, false otherwise</p>
<pre class="source">
bool isAttached() {
 return _attached;
}
</pre>
</div>
</div>
<div class="method"><h4 id="isFocusOnHoverEnabled">
<button class="show-code">Code</button>
bool <strong>isFocusOnHoverEnabled</strong>() <a class="anchor-link" href="#isFocusOnHoverEnabled"
              title="Permalink to MenuBar.isFocusOnHoverEnabled">#</a></h4>
<div class="doc">
<p>Check whether or not this widget will steal keyboard focus when the mouse
hovers over it.</p>
<p>@return true if enabled, false if disabled</p>
<pre class="source">
bool isFocusOnHoverEnabled() {
 return _focusOnHover;
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="isOrWasAttached">
<button class="show-code">Code</button>
bool <strong>isOrWasAttached</strong>() <a class="anchor-link" href="#isOrWasAttached"
              title="Permalink to MenuBar.isOrWasAttached">#</a></h4>
<div class="inherited-from">inherited from <a href="../dart_web_toolkit_ui/Widget.html">Widget</a> </div><div class="doc">
<p>Has this widget ever been attached?</p>
<p>@return true if this widget ever been attached to the DOM, false otherwise</p>
<pre class="source">
bool isOrWasAttached() {
 return eventsToSink == -1;
}
</pre>
</div>
</div>
<div class="method"><h4 id="itemOver">
<button class="show-code">Code</button>
void <strong>itemOver</strong>(<a href="../dart_web_toolkit_ui/MenuItem.html">MenuItem</a> item, bool pFocus) <a class="anchor-link" href="#itemOver"
              title="Permalink to MenuBar.itemOver">#</a></h4>
<div class="doc">
<pre class="source">
void itemOver(MenuItem item, bool pFocus) {
 if (item == null) {
   // Don't clear selection if the currently selected item's menu is showing.
   if ((_selectedItem != null)
       &amp;&amp; (_shownChildMenu == _selectedItem.getSubMenu())) {
     return;
   }
 }

 if (item != null &amp;&amp; !item.enabled) {
   return;
 }

 // Style the item selected when the mouse enters.
 selectItem(item);
 if (pFocus &amp;&amp; _focusOnHover) {
   focus();
 }

 // If child menus are being shown, or this menu is itself
 // a child menu, automatically show an item's child menu
 // when the mouse enters.
 if (item != null) {
   if ((_shownChildMenu != null) || (_parentMenu != null) || _autoOpen) {
     doItemAction(item, false, _focusOnHover);
   }
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="moveSelectionDown">
<button class="show-code">Code</button>
void <strong>moveSelectionDown</strong>() <a class="anchor-link" href="#moveSelectionDown"
              title="Permalink to MenuBar.moveSelectionDown">#</a></h4>
<div class="doc">
<p>Moves the menu selection down to the next item. If there is no selection,
selects the first item. If there are no items at all, does nothing.</p>
<pre class="source">
void moveSelectionDown() {
 if (_selectFirstItemIfNoneSelected()) {
   return;
 }

 if (_vertical) {
   _selectNextItem();
 } else {
   if (_selectedItem.getSubMenu() != null
       &amp;&amp; !_selectedItem.getSubMenu().getItems().isEmpty
       &amp;&amp; (_shownChildMenu == null || _shownChildMenu.getSelectedItem() == null)) {
     if (_shownChildMenu == null) {
       doItemAction(_selectedItem, false, true);
     }
     _selectedItem.getSubMenu().focus();
   } else if (_parentMenu != null) {
     if (_parentMenu._vertical) {
       _parentMenu._selectNextItem();
     } else {
       _parentMenu.moveSelectionDown();
     }
   }
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="moveSelectionUp">
<button class="show-code">Code</button>
void <strong>moveSelectionUp</strong>() <a class="anchor-link" href="#moveSelectionUp"
              title="Permalink to MenuBar.moveSelectionUp">#</a></h4>
<div class="doc">
<p>Moves the menu selection up to the previous item. If there is no selection,
selects the first item. If there are no items at all, does nothing.</p>
<pre class="source">
void moveSelectionUp() {
 if (_selectFirstItemIfNoneSelected()) {
   return;
 }

 if ((_shownChildMenu == null) &amp;&amp; _vertical) {
   _selectPrevItem();
 } else if ((_parentMenu != null) &amp;&amp; _parentMenu._vertical) {
   _parentMenu._selectPrevItem();
 } else {
   _close(true);
 }
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="onAttach">
<button class="show-code">Code</button>
void <strong>onAttach</strong>() <a class="anchor-link" href="#onAttach"
              title="Permalink to MenuBar.onAttach">#</a></h4>
<div class="inherited-from">inherited from <a href="../dart_web_toolkit_ui/Widget.html">Widget</a> </div><div class="doc">
<p>
This method is called when a widget is attached to the browser's document.
To receive notification after a Widget has been added to the document,
override the {@link #onLoad} method or use {@link #addAttachHandler}.
</p>
<p>
It is strongly recommended that you override {@link #onLoad()} or
{@link #doAttachChildren()} instead of this method to avoid inconsistencies
between logical and physical attachment states.
</p>
<p>
Subclasses that override this method must call
<code>super.onAttach()</code> to ensure that the Widget has been attached
to its underlying Element.
</p>
<p>@throws IllegalStateException if this widget is already attached
@see #onLoad()
@see #doAttachChildren()</p>
<pre class="source">
void onAttach() {
 if (isAttached()) {
   throw new Exception("Should only call onAttach when the widget is detached from the browser's document");
 }

 _attached = true;

 // Event hookup code
 Dom.setEventListener(getElement(), this);
 int bitsToAdd = eventsToSink;
 eventsToSink = -1;
 if (bitsToAdd &gt; 0) {
   sinkEvents(bitsToAdd);
 }
 doAttachChildren();

 // onLoad() gets called only *after* all of the children are attached and
 // the attached flag is set. This allows widgets to be notified when they
 // are fully attached, and panels when all of their children are attached.
 onLoad();
 AttachEvent.fire(this, true);
}
</pre>
</div>
</div>
<div class="method"><h4 id="onBrowserEvent">
<button class="show-code">Code</button>
void <strong>onBrowserEvent</strong>(Event event) <a class="anchor-link" href="#onBrowserEvent"
              title="Permalink to MenuBar.onBrowserEvent">#</a></h4>
<div class="doc">
<div class="inherited">
<p>Fired whenever a browser event is received.</p>
<p>@param event the event received</p>
<p>TODO</p>
<div class="docs-inherited-from">docs inherited from <a href="../dart_web_toolkit_ui/Widget.html">Widget</a> </div></div>
<pre class="source">
void onBrowserEvent(dart_html.Event event) {
 MenuItem item = _findItem(event.target);
 switch (Dom.eventGetType(event)) {
   case IEvent.ONCLICK:
     FocusPanel.impl.focus(getElement());
     // Fire an item's command when the user clicks on it.
     if (item != null) {
       doItemAction(item, true, true);
     }
     break;

   case IEvent.ONMOUSEOVER:
     if (item != null) {
       itemOver(item, true);
     }
     break;

   case IEvent.ONMOUSEOUT:
     if (item != null) {
       itemOver(null, true);
     }
     break;

   case IEvent.ONFOCUS:
     _selectFirstItemIfNoneSelected();
     break;

   case IEvent.ONKEYDOWN:
     dart_html.KeyboardEvent kEvent = event as dart_html.KeyboardEvent;
     int keyCode = kEvent.keyCode;
     switch (keyCode) {
       case KeyCodes.KEY_LEFT:
         if (LocaleInfo.getCurrentLocale().isRTL()) {
           _moveToNextItem();
         } else {
           _moveToPrevItem();
         }
         _eatEvent(event);
         break;
       case KeyCodes.KEY_RIGHT:
         if (LocaleInfo.getCurrentLocale().isRTL()) {
           _moveToPrevItem();
         } else {
           _moveToNextItem();
         }
         _eatEvent(event);
         break;
       case KeyCodes.KEY_UP:
         moveSelectionUp();
         _eatEvent(event);
         break;
       case KeyCodes.KEY_DOWN:
         moveSelectionDown();
         _eatEvent(event);
         break;
       case KeyCodes.KEY_ESCAPE:
         closeAllParentsAndChildren();
         _eatEvent(event);
         break;
       case KeyCodes.KEY_TAB:
         closeAllParentsAndChildren();
         break;
       case KeyCodes.KEY_ENTER:
         if (!_selectFirstItemIfNoneSelected()) {
           doItemAction(_selectedItem, true, true);
           _eatEvent(event);
         }
         break;
     } // end switch(keyCode)

     break;
 } // end switch (Dom.eventGetType(event))
 super.onBrowserEvent(event);
}
</pre>
</div>
</div>
<div class="method"><h4 id="onDetach">
<button class="show-code">Code</button>
void <strong>onDetach</strong>() <a class="anchor-link" href="#onDetach"
              title="Permalink to MenuBar.onDetach">#</a></h4>
<div class="doc">
<div class="inherited">
<p>
This method is called when a widget is detached from the browser's
document. To receive notification before a Widget is removed from the
document, override the {@link #onUnload} method or use {@link #addAttachHandler}.
</p>
<p>
It is strongly recommended that you override {@link #onUnload()} or
{@link #doDetachChildren()} instead of this method to avoid inconsistencies
between logical and physical attachment states.
</p>
<p>
Subclasses that override this method must call
<code>super.onDetach()</code> to ensure that the Widget has been detached
from the underlying Element. Failure to do so will result in application
memory leaks due to circular references between DOM Elements and JavaScript
objects.
</p>
<p>@throws IllegalStateException if this widget is already detached
@see #onUnload()
@see #doDetachChildren()</p>
<div class="docs-inherited-from">docs inherited from <a href="../dart_web_toolkit_ui/Widget.html">Widget</a> </div></div>
<pre class="source">
void onDetach() {
 // When the menu is detached, make sure to close all of its children.
 if (_popup != null) {
   _popup.hide();
 }

 super.onDetach();
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="onLoad">
<button class="show-code">Code</button>
void <strong>onLoad</strong>() <a class="anchor-link" href="#onLoad"
              title="Permalink to MenuBar.onLoad">#</a></h4>
<div class="inherited-from">inherited from <a href="../dart_web_toolkit_ui/Widget.html">Widget</a> </div><div class="doc">
<p>This method is called immediately after a widget becomes attached to the
browser's document.</p>
<pre class="source">
void onLoad() {
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="onUnload">
<button class="show-code">Code</button>
void <strong>onUnload</strong>() <a class="anchor-link" href="#onUnload"
              title="Permalink to MenuBar.onUnload">#</a></h4>
<div class="inherited-from">inherited from <a href="../dart_web_toolkit_ui/Widget.html">Widget</a> </div><div class="doc">
<p>This method is called immediately before a widget will be detached from the
browser's document.</p>
<pre class="source">
void onUnload() {
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="removeFromParent">
<button class="show-code">Code</button>
void <strong>removeFromParent</strong>() <a class="anchor-link" href="#removeFromParent"
              title="Permalink to MenuBar.removeFromParent">#</a></h4>
<div class="inherited-from">inherited from <a href="../dart_web_toolkit_ui/Widget.html">Widget</a> </div><div class="doc">
<p>Removes this widget from its parent widget, if one exists.</p><p>
If it has no parent, this method does nothing. If it is a "root" widget
(meaning it's been added to the detach list via
{@link RootPanel#detachOnWindowClose(Widget)}), it will be removed from the
detached immediately. This makes it possible for Composites and Panels to
adopt root widgets.
</p>
<p>@throws IllegalStateException if this widget's parent does not support</p>
<pre><code>      removal (e.g. {@link Composite})
</code></pre>
<pre class="source">
void removeFromParent() {
 if (_parent == null) {
   // If the widget had no parent, check to see if it was in the detach list
   // and remove it if necessary.
   if (RootPanel.isInDetachList(this)) {
     RootPanel.detachNow(this);
   }
 } else if (_parent is HasWidgets) {
   (_parent as HasWidgets).remove(this);
 } else if (_parent != null) {
   throw new Exception("This widget's parent does not implement HasWidgets");
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="removeItem">
<button class="show-code">Code</button>
void <strong>removeItem</strong>(<a href="../dart_web_toolkit_ui/MenuItem.html">MenuItem</a> item) <a class="anchor-link" href="#removeItem"
              title="Permalink to MenuBar.removeItem">#</a></h4>
<div class="doc">
<p>Closes the menu bar.</p>
<p>@deprecated Use {@link #addCloseHandler(CloseHandler)} instead</p>
<p>Removes the specified menu item from the bar.</p>
<p>@param item the item to be removed</p>
<pre class="source">
void removeItem(MenuItem item) {
 // Unselect if the item is currently selected
 if (_selectedItem == item) {
   selectItem(null);
 }

 if (_removeItemElement(item)) {
   _setItemColSpan(item, 1);
   _items.remove(item);
   item.setParentMenu(null);
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="removeSeparator">
<button class="show-code">Code</button>
void <strong>removeSeparator</strong>(<a href="../dart_web_toolkit_ui/MenuItemSeparator.html">MenuItemSeparator</a> separator) <a class="anchor-link" href="#removeSeparator"
              title="Permalink to MenuBar.removeSeparator">#</a></h4>
<div class="doc">
<p>Removes the specified {@link MenuItemSeparator} from the bar.</p>
<p>@param separator the separator to be removed</p>
<pre class="source">
void removeSeparator(MenuItemSeparator separator) {
 if (_removeItemElement(separator)) {
   separator.setParentMenu(null);
 }
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="removeStyleDependentName">
<button class="show-code">Code</button>
void <strong>removeStyleDependentName</strong>(String styleSuffix) <a class="anchor-link" href="#removeStyleDependentName"
              title="Permalink to MenuBar.removeStyleDependentName">#</a></h4>
<div class="inherited-from">inherited from <a href="../dart_web_toolkit_ui/UiObject.html">UiObject</a> </div><div class="doc">
<p>Removes a dependent style name by specifying the style name's suffix.</p>
<p>@param styleSuffix the suffix of the dependent style to be removed
@see #setStylePrimaryName(Element, String)
@see #addStyleDependentName(String)
@see #setStyleDependentName(String, boolean)</p>
<pre class="source">
void removeStyleDependentName(String styleSuffix) {
 setStyleDependentName(styleSuffix, false);
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="removeStyleName">
<button class="show-code">Code</button>
void <strong>removeStyleName</strong>(String style) <a class="anchor-link" href="#removeStyleName"
              title="Permalink to MenuBar.removeStyleName">#</a></h4>
<div class="inherited-from">inherited from <a href="../dart_web_toolkit_ui/UiObject.html">UiObject</a> </div><div class="doc">
<p>Removes a style name. This method is typically used to remove secondary
style names, but it can be used to remove primary stylenames as well. That
use is not recommended.</p>
<p>@param style the secondary style name to be removed
@see #addStyleName(String)
@see #setStyleName(String, boolean)</p>
<pre class="source">
void removeStyleName(String style) {
 setStyleName(style, false);
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="replaceElement">
<button class="show-code">Code</button>
void <strong>replaceElement</strong>(Element elem) <a class="anchor-link" href="#replaceElement"
              title="Permalink to MenuBar.replaceElement">#</a></h4>
<div class="inherited-from">inherited from <a href="../dart_web_toolkit_ui/Widget.html">Widget</a> </div><div class="doc">
<p>Replaces this object's browser element.</p>
<p>This method exists only to support a specific use-case in Image, and should
not be used by other classes.</p>
<p>@param elem the object's new element</p>
<pre class="source">
void replaceElement(dart_html.Element elem) {
 if (isAttached()) {
   // Remove old event listener to avoid leaking. onDetach will not do this
   // for us, because it is only called when the widget itself is detached
   // from the document.
   Dom.setEventListener(getElement(), null);
 }

 super.replaceElement(elem);

 if (isAttached()) {
   // Hook the event listener back up on the new element. onAttach will not
   // do this for us, because it is only called when the widget itself is
   // attached to the document.
   Dom.setEventListener(getElement(), this);
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="selectItem">
<button class="show-code">Code</button>
void <strong>selectItem</strong>(<a href="../dart_web_toolkit_ui/MenuItem.html">MenuItem</a> item) <a class="anchor-link" href="#selectItem"
              title="Permalink to MenuBar.selectItem">#</a></h4>
<div class="doc">
<p>Select the given MenuItem, which must be a direct child of this MenuBar.</p>
<p>@param item the MenuItem to select, or null to clear selection</p>
<pre class="source">
void selectItem(MenuItem item) {
 assert (item == null || item.getParentMenu() == this);

 if (item == _selectedItem) {
   return;
 }

 if (_selectedItem != null) {
   _selectedItem.setSelectionStyle(false);
   // Set the style of the submenu indicator
   if (_vertical) {
     dart_html.Element tr = _selectedItem.getElement().parent;
     if (Dom.getChildCount(tr) == 2) {
       dart_html.Element td = Dom.getChild(tr, 1);
       UiObject.manageElementStyleName(td, "subMenuIcon-selected", false);
     }
   }
 }

 if (item != null) {
   item.setSelectionStyle(true);

   // Set the style of the submenu indicator
   if (_vertical) {
     dart_html.Element tr = item.getElement().parent;
     if (tr.children.length == 2) {
       dart_html.Element td = tr.children[1];
       UiObject.manageElementStyleName(td, "subMenuIcon-selected", true);
     }
   }

//      Roles.getMenubarRole().setAriaActivedescendantProperty(getElement(),
//          IdReference.of(Dom.getElementAttribute(item.getElement(), "id")));
 }

 _selectedItem = item;
}
</pre>
</div>
</div>
<div class="method"><h4 id="setAnimationEnabled">
<button class="show-code">Code</button>
void <strong>setAnimationEnabled</strong>(bool enable) <a class="anchor-link" href="#setAnimationEnabled"
              title="Permalink to MenuBar.setAnimationEnabled">#</a></h4>
<div class="doc">
<div class="inherited">
<p>Enable or disable animations.</p>
<p>@param enable true to enable, false to disable</p>
<div class="docs-inherited-from">docs inherited from <a href="../dart_web_toolkit_event/HasAnimation.html">HasAnimation</a> </div></div>
<pre class="source">
void setAnimationEnabled(bool enable) {
 _isAnimationEnabled = enable;
}
</pre>
</div>
</div>
<div class="method"><h4 id="setAutoOpen">
<button class="show-code">Code</button>
void <strong>setAutoOpen</strong>(bool autoOpen) <a class="anchor-link" href="#setAutoOpen"
              title="Permalink to MenuBar.setAutoOpen">#</a></h4>
<div class="doc">
<p>Sets whether this menu bar's child menus will open when the mouse is moved
over it.</p>
<p>@param autoOpen &lt;code>true&lt;/code> to cause child menus to auto-open</p>
<pre class="source">
void setAutoOpen(bool autoOpen) {
 this._autoOpen = autoOpen;
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="setElement">
<button class="show-code">Code</button>
void <strong>setElement</strong>(Element elem) <a class="anchor-link" href="#setElement"
              title="Permalink to MenuBar.setElement">#</a></h4>
<div class="inherited-from">inherited from <a href="../dart_web_toolkit_ui/UiObject.html">UiObject</a> </div><div class="doc">
<p>Sets this object's browser element. UIObject subclasses must call this
method before attempting to call any other methods, and it may only be
called once.</p>
<p>@param elem the object's element</p>
<pre class="source">
void setElement(dart_html.Element elem) {
 assert (_element == null);
 this._element = elem;
}
</pre>
</div>
</div>
<div class="method"><h4 id="setFocusOnHoverEnabled">
<button class="show-code">Code</button>
void <strong>setFocusOnHoverEnabled</strong>(bool enabled) <a class="anchor-link" href="#setFocusOnHoverEnabled"
              title="Permalink to MenuBar.setFocusOnHoverEnabled">#</a></h4>
<div class="doc">
<p>Enable or disable auto focus when the mouse hovers over the MenuBar. This
allows the MenuBar to respond to keyboard events without the user having to
click on it, but it will steal focus from other elements on the page.
Enabled by default.</p>
<p>@param enabled true to enable, false to disable</p>
<pre class="source">
void setFocusOnHoverEnabled(bool enabled) {
 _focusOnHover = enabled;
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="setHeight">
<button class="show-code">Code</button>
void <strong>setHeight</strong>(String height) <a class="anchor-link" href="#setHeight"
              title="Permalink to MenuBar.setHeight">#</a></h4>
<div class="inherited-from">inherited from <a href="../dart_web_toolkit_ui/UiObject.html">UiObject</a> </div><div class="doc">
<p>Sets the object's height. This height does not include decorations such as
border, margin, and padding.</p>
<p>@param height the object's new height, in CSS units (e.g. "10px", "1em")</p>
<pre class="source">
void setHeight(String height) {
 // This exists to deal with an inconsistency in IE's implementation where
 // it won't accept negative numbers in length measurements
 assert (extractLengthValue(height.trim().toLowerCase()) &gt;= 0); // : "CSS heights should not be negative";
 Dom.setStyleAttribute(getElement(), "height", height);
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="setLayoutData">
<button class="show-code">Code</button>
void <strong>setLayoutData</strong>(Object value) <a class="anchor-link" href="#setLayoutData"
              title="Permalink to MenuBar.setLayoutData">#</a></h4>
<div class="inherited-from">inherited from <a href="../dart_web_toolkit_ui/Widget.html">Widget</a> </div><div class="doc">
<p>Sets the panel-defined layout data associated with this widget. Only the
panel that currently contains a widget should ever set this value. It
serves as a place to store layout bookkeeping data associated with a
widget.</p>
<p>@param layoutData the widget's layout data</p>
<pre class="source">
void setLayoutData(Object value) {
 this._layoutData = value;
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="setParent">
<button class="show-code">Code</button>
void <strong>setParent</strong>(<a href="../dart_web_toolkit_ui/Widget.html">Widget</a> parent) <a class="anchor-link" href="#setParent"
              title="Permalink to MenuBar.setParent">#</a></h4>
<div class="inherited-from">inherited from <a href="../dart_web_toolkit_ui/Widget.html">Widget</a> </div><div class="doc">
<p>Sets this widget's parent. This method should only be called by
{@link Panel} and {@link Composite}.</p>
<p>@param parent the widget's new parent
@throws IllegalStateException if &lt;code>parent&lt;/code> is non-null and the</p>
<pre><code>      widget already has a parent
</code></pre>
<pre class="source">
void setParent(Widget parent) {
 Widget oldParent = this._parent;
 if (parent == null) {
   try {
     if (oldParent != null &amp;&amp; oldParent.isAttached()) {
       onDetach();
       assert (!isAttached()); // : "Failure of " + this.getClass().getName() + " to call super.onDetach()";
     }
   } finally {
     // Put this in a finally in case onDetach throws an exception.
     this._parent = null;
   }
 } else {
   if (oldParent != null) {
     throw new Exception("Cannot set a new parent without first clearing the old parent");
   }
   this._parent = parent;
   if (parent.isAttached()) {
     onAttach();
     assert (isAttached()); // : "Failure of " + this.getClass().getName() + " to call super.onAttach()";
   }
 }
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="setPixelSize">
<button class="show-code">Code</button>
void <strong>setPixelSize</strong>(int width, int height) <a class="anchor-link" href="#setPixelSize"
              title="Permalink to MenuBar.setPixelSize">#</a></h4>
<div class="inherited-from">inherited from <a href="../dart_web_toolkit_ui/UiObject.html">UiObject</a> </div><div class="doc">
<p>Sets the object's size, in pixels, not including decorations such as
border, margin, and padding.</p>
<p>@param width the object's new width, in pixels
@param height the object's new height, in pixels</p>
<pre class="source">
void setPixelSize(int width, int height) {
 if (width &gt;= 0) {
   setWidth(width.toString() + "px");
 }
 if (height &gt;= 0) {
   setHeight(height.toString() + "px");
 }
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="setSize">
<button class="show-code">Code</button>
void <strong>setSize</strong>(String width, String height) <a class="anchor-link" href="#setSize"
              title="Permalink to MenuBar.setSize">#</a></h4>
<div class="inherited-from">inherited from <a href="../dart_web_toolkit_ui/UiObject.html">UiObject</a> </div><div class="doc">
<p>Sets the object's size. This size does not include decorations such as
border, margin, and padding.</p>
<p>@param width the object's new width, in CSS units (e.g. "10px", "1em")
@param height the object's new height, in CSS units (e.g. "10px", "1em")</p>
<pre class="source">
void setSize(String width, String height) {
 setWidth(width);
 setHeight(height);
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="setStyleDependentName">
<button class="show-code">Code</button>
void <strong>setStyleDependentName</strong>(String styleSuffix, bool add) <a class="anchor-link" href="#setStyleDependentName"
              title="Permalink to MenuBar.setStyleDependentName">#</a></h4>
<div class="inherited-from">inherited from <a href="../dart_web_toolkit_ui/UiObject.html">UiObject</a> </div><div class="doc">
<p>Adds or removes a dependent style name by specifying the style name's
suffix. The actual form of the style name that is added is:</p><pre class="code">
getStylePrimaryName() + '-' + styleSuffix
</pre>
<p>@param styleSuffix the suffix of the dependent style to be added or removed
@param add &lt;code>true&lt;/code> to add the given style, &lt;code>false&lt;/code> to</p>
<pre><code>     remove it
</code></pre>
<p>@see #setStylePrimaryName(Element, String)
@see #addStyleDependentName(String)
@see #setStyleName(String, boolean)
@see #removeStyleDependentName(String)</p>
<pre class="source">
void setStyleDependentName(String styleSuffix, bool add) {
 setStyleName(getStylePrimaryName() + '-' + styleSuffix, add);
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="setStyleName">
<button class="show-code">Code</button>
void <strong>setStyleName</strong>(String style, bool add) <a class="anchor-link" href="#setStyleName"
              title="Permalink to MenuBar.setStyleName">#</a></h4>
<div class="inherited-from">inherited from <a href="../dart_web_toolkit_ui/UiObject.html">UiObject</a> </div><div class="doc">
<p>Adds or removes a style name. This method is typically used to remove
secondary style names, but it can be used to remove primary stylenames as
well. That use is not recommended.</p>
<p>@param style the style name to be added or removed
@param add &lt;code>true&lt;/code> to add the given style, &lt;code>false&lt;/code> to</p>
<pre><code>     remove it
</code></pre>
<p>@see #addStyleName(String)
@see #removeStyleName(String)</p>
<pre class="source">
void setStyleName(String style, bool add) {
 manageElementStyleName(getStyleElement(), style, add);
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="setStylePrimaryName">
<button class="show-code">Code</button>
void <strong>setStylePrimaryName</strong>(String style) <a class="anchor-link" href="#setStylePrimaryName"
              title="Permalink to MenuBar.setStylePrimaryName">#</a></h4>
<div class="inherited-from">inherited from <a href="../dart_web_toolkit_ui/UiObject.html">UiObject</a> </div><div class="doc">
<p>Sets the object's primary style name and updates all dependent style names.</p>
<p>@param style the new primary style name
@see #addStyleName(String)
@see #removeStyleName(String)</p>
<pre class="source">
void setStylePrimaryName(String style) {
 setElementStylePrimaryName(getStyleElement(), style);
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="setWidth">
<button class="show-code">Code</button>
void <strong>setWidth</strong>(String width) <a class="anchor-link" href="#setWidth"
              title="Permalink to MenuBar.setWidth">#</a></h4>
<div class="inherited-from">inherited from <a href="../dart_web_toolkit_ui/UiObject.html">UiObject</a> </div><div class="doc">
<p>Sets the object's width. This width does not include decorations such as
border, margin, and padding.</p>
<p>@param width the object's new width, in CSS units (e.g. "10px", "1em")</p>
<pre class="source">
void setWidth(String width) {
 // This exists to deal with an inconsistency in IE's implementation where
 // it won't accept negative numbers in length measurements
 assert (extractLengthValue(width.trim().toLowerCase()) &gt;= 0); // : "CSS widths should not be negative";
 Dom.setStyleAttribute(getElement(), "width", width);
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="sinkBitlessEvent">
<button class="show-code">Code</button>
void <strong>sinkBitlessEvent</strong>(String eventTypeName) <a class="anchor-link" href="#sinkBitlessEvent"
              title="Permalink to MenuBar.sinkBitlessEvent">#</a></h4>
<div class="inherited-from">inherited from <a href="../dart_web_toolkit_ui/UiObject.html">UiObject</a> </div><div class="doc">
<p>Sinks a named event. Note that only {@link Widget widgets} may actually
receive events, but can receive events from all objects contained within
them.</p>
<p>@param eventTypeName name of the event to sink on this element
@see com.google.gwt.user.client.Event</p>
<pre class="source">
void sinkBitlessEvent(String eventTypeName) {
 Dom.sinkBitlessEvent(getElement(), eventTypeName);
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="sinkEvents">
<button class="show-code">Code</button>
void <strong>sinkEvents</strong>(int eventBitsToAdd) <a class="anchor-link" href="#sinkEvents"
              title="Permalink to MenuBar.sinkEvents">#</a></h4>
<div class="inherited-from">inherited from <a href="../dart_web_toolkit_ui/Widget.html">Widget</a> </div><div class="doc">
<p>Overridden to defer the call to super.sinkEvents until the first time this
widget is attached to the dom, as a performance enhancement. Subclasses
wishing to customize sinkEvents can preserve this deferred sink behavior by
putting their implementation behind a check of
&lt;code>isOrWasAttached()&lt;/code>:</p><pre>
{@literal @}Override
public void sinkEvents(int eventBitsToAdd) {
  if (isOrWasAttached()) {
    /{@literal *} customized sink code goes here {@literal *}/
  } else {
    super.sinkEvents(eventBitsToAdd);
 }
} </pre>
<pre class="source">
void sinkEvents(int eventBitsToAdd) {
 if (isOrWasAttached()) {
   super.sinkEvents(eventsToSink);
 } else {
   eventsToSink |= eventBitsToAdd;
 }
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="toString">
<button class="show-code">Code</button>
String <strong>toString</strong>() <a class="anchor-link" href="#toString"
              title="Permalink to MenuBar.toString">#</a></h4>
<div class="inherited-from">inherited from <a href="../dart_web_toolkit_ui/UiObject.html">UiObject</a> </div><div class="doc">
<p>This method is overridden so that any object can be viewed in the debugger
as an HTML snippet.</p>
<p>@return a string representation of the object</p>
<pre class="source">
String toString() {
 if (_element == null) {
   return "(null handle)";
 }
 return getElement().toString();
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="unsinkEvents">
<button class="show-code">Code</button>
void <strong>unsinkEvents</strong>(int eventBitsToRemove) <a class="anchor-link" href="#unsinkEvents"
              title="Permalink to MenuBar.unsinkEvents">#</a></h4>
<div class="inherited-from">inherited from <a href="../dart_web_toolkit_ui/UiObject.html">UiObject</a> </div><div class="doc">
<p>Removes a set of events from this object's event list.</p>
<p>@param eventBitsToRemove a bitfield representing the set of events to be</p>
<pre><code>     removed from this element's event set
</code></pre>
<p>@see #sinkEvents
@see com.google.gwt.user.client.Event</p>
<pre class="source">
void unsinkEvents(int eventBitsToRemove) {
 Dom.sinkEvents(getElement(), Dom.getEventsSunk(getElement()) &amp; (~eventBitsToRemove));
}
</pre>
</div>
</div>
<div class="method"><h4 id="updateSubmenuIcon">
<button class="show-code">Code</button>
void <strong>updateSubmenuIcon</strong>(<a href="../dart_web_toolkit_ui/MenuItem.html">MenuItem</a> item) <a class="anchor-link" href="#updateSubmenuIcon"
              title="Permalink to MenuBar.updateSubmenuIcon">#</a></h4>
<div class="doc">
<p>Show or hide the icon used for items with a submenu.</p>
<p>@param item the item with or without a submenu</p>
<pre class="source">
void updateSubmenuIcon(MenuItem item) {
 // The submenu icon only applies to vertical menus
 if (!_vertical) {
   return;
 }

 // Get the index of the MenuItem
 int idx = _allItems.indexOf(item);
 if (idx == -1) {
   return;
 }

 dart_html.Element container = _getItemContainerElement();
 dart_html.Element tr = Dom.getChild(container, idx);
 int tdCount = Dom.getChildCount(tr);
 MenuBar submenu = item.getSubMenu();
 if (submenu == null) {
   // Remove the submenu indicator
   if (tdCount == 2) {
     //Dom.removeChild(tr, Dom.getChild(tr, 1));
     Dom.getChild(tr, 1).remove();
   }
   _setItemColSpan(item, 2);
 } else if (tdCount == 1) {
   // Show the submenu indicator
   _setItemColSpan(item, 1);
   dart_html.Element td = new dart_html.TableCellElement();
   td.style.verticalAlign = "middle";
   td.append(_subMenuIcon.createElement());
   UiObject.setElementStyleName(td, "subMenuIcon");
   tr.append(td);
 }
}
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          <div>This page was generated at 2013-05-06 21:36:13.293</div>
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        
